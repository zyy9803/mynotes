[TOC]



# 欠缺的知识点

* http 2.0 多路复用怎么实现的
* post 相较于 get 安全性更高是怎么体现的
* TCP 可靠传输和拥塞控制是怎么实现的，UDP如何在应用层实现可靠传输
* npm 包管理策略
* 迭代器
* less/sass 如何转化为 css
* 熟悉 webpack
* HTTP 相关
* Vue diff算法，key作用
* 函数柯里化
* JavaScript 单例模式
* nextTick原理
* async / await 原理
* 前端性能优化
* 前端上传大文件



# 项目



## Vue播放器

一句话总结：单页面富应用，主要的页面有正在播放、热歌榜单、歌曲搜索、我的歌单、历史收听。

### 后端接口

项目的后端是 Github 的一个开源项目提供，开放了网易云的接口，可以获取音乐信息和资源，后端支持 CORS 跨域请求，因此我使用 Axios 发送 http 请求，之后通过返回的Promise对象对数据进行处理，将不同的接口和数据处理函数封装成了一个 js 文件，便于调用。



### 路由管理

主要有五个页面：正在播放、歌单推荐、搜索、我的歌单、历史播放

因此使用 Vue-router 管理路由，路由模式为hash模式，采取路由懒加载，使用router-view和router-link实现路由的跳转。

获取路由中的数据：`this.$route.params.xxx`，在 details 组件中有用到



### 状态管理

这个项目比较麻烦的是状态管理，因为在不同的页面内，都有可能触发歌曲的播放、暂停，歌单的切换、歌单歌曲的增添，因此我引入Vuex进行状态管理，主要管理了播放状态、播放列表、播放器元素、UID、播放模式、历史播放等状态，其中UID和历史播放记录使用 localStorage 做了持久化，并进行了二次封装方便调用。通过mutations进行状态改变，通过action进行异步状态改变。普通的父子组件通信使用props和自定义事件，跨级组件通信使用Vuex。在主页面 Music 中通过 watch 监听播放状态、当前播放歌曲、播放进度的改变，来控制 audio 元素进行播放的改变。 

localStorage常用的三个方法：getItem, setItem, removeItem

```js
const _storage = window.localStorage
const storage = {
  get(key, data = []) {
    if (_storage) {
      return _storage.getItem(key)
        ? Array.isArray(data)
          ? JSON.parse(_storage.getItem(key))
          : _storage.getItem(key)
        : data
    }
  },
  set(key, val) {
    if (_storage) {
      _storage.setItem(key, val)
    }
  },
  clear(key) {
    if (_storage) {
      _storage.removeItem(key)
    }
  }
}
```



### 布局

布局方面采用 less 预处理器进行 css 处理，使 css 层级明显，更具可读性。布局方面主要采用流式布局结合flex布局实现响应式。



### 重要的组件

主要的组件有 header、button、lyric、music-list、progress 等

* header 组件：实现了登陆功能
* button 组件：实现 router 的跳转
* lyric 组件：实现歌词的滚动播放、当前播放歌词的高亮显示
* progress 组件：复用实现进度条和音量调节功能
* music-list 组件：传入歌曲数据，展示歌单



#### Music中枢

放置头部、内容、播放器、歌词等组件的容器，进行集中控制



#### MusicList

歌单列表组件，由头部和滚动视窗和底部的清除歌单组成

传入处理好的list数据显示歌单列表，可以实现播放停止、删除歌单，但不在本组件中进行操作，将信息传递到上一层（PlayList / HistoryList等）中进行操作，通过引入 Icon 组件，实现鼠标悬停出现播放暂停和删除按钮



#### Progress组件

复用实现进度条和音量调节功能

一共有三个条浅中深，根据传入的 percent 和 percentProgress 值，计算当前宽度下的偏移量，并修改 width 值，同时定义鼠标点击和拖动事件，根据鼠标弹起时的位置计算值，并进行显示，同时传递出数据，改变progress值，在Music 组件中接收 progress ，修改 currentTime，currentTime通过 watch 监测改变时，修改 lyric 组件对应的歌词位置

```vue
  watch: {
    percent(newPercent) {
      if (newPercent >= 0 && !this.move.status) {
        const barWidth = this.$refs.cProgress.clientWidth - dotWidth;
        const offsetWidth = newPercent * barWidth;
        this.moveSlide(offsetWidth);
      }
    },
    percentProgress(newValue) {
      let offsetWidth = this.$refs.cProgress.clientWidth * newValue;
      this.$refs.cPercentProgress.style.width = `${offsetWidth}px`;
    },

	// Methods中
	moveSlide(offsetWidth) {
      this.$refs.cProgressInner.style.width = `${offsetWidth}px`;
	}
```



#### Lyric组件

每一句歌词包裹一个 p 标签，固定标签的高度，实时传入 lyricIndex (currentTime 中计算) 进行歌词滚动，并实现高亮

```vue
<div class="music-lyric-items" :style="lyricTop">
  <p v-if="!currentMusic.id">还未播放音乐</p>
  <p v-else-if="nolyric">暂无歌词</p>
  <template v-else-if="lyric.length > 0">
    <p
      v-for="(item, index) in lyric"
      :key="index"
      :class="{ on: lyricIndex === index }"
    >
      {{ item.text }}
    </p>
  </template>
  <p v-else>歌词加载失败</p>
</div>



computed: {
    musicPic() {
      return this.currentMusic.image
        ? this.currentMusic.image
        : require("../../assets/img/player_cover.png");
    },
    // 歌词滚动
    lyricTop() {
      return `transform: translate3d(0,${
        -34 * (this.lyricIndex - this.top)
      }px,0)`;
    },
    ...mapGetters(["currentMusic"]),
  },
```





## 后台管理系统

在主页面使用 container 布局容器

`<el-container>`：外层容器。当子元素中包含 `<el-header>` 或 `<el-footer>` 时，全部子元素会垂直上下排列，否则会水平左右排列。

`<el-header>`：顶栏容器。

`<el-aside>`：侧边栏容器。

`<el-main>`：主要区域容器。

`<el-footer>`：底栏容器。



### 侧边栏

封装成组件，使用 NavMenu 进行侧边导航，使用`this.$route.push()`进行路由跳转

```vue
  <el-menu
    default-active="1-4-1"
    class="el-menu-vertical-demo"
    background-color="#545c65"
    text-color="#fff"
    active-text-color="#ffd04b"
    @open="handleOpen"
    @close="handleClose"
    :collapse="isCollapse"
  >
      //省略了部分内容
     <el-menu-item
      @click="clickMenu(item)"
      v-for="item in noChildren"
      :index="item.path"
      :key="item.path"
    >
      <i :class="'el-icon-' + item.icon"></i>
      <span slot="title">{{ item.label }}</span>
    </el-menu-item>
     //省略
  </el-menu>
```



### Header组件

引入 el-button、el-dropdown组件实现对侧边栏伸缩的控制（用事件总线）、点击图像下拉菜单



### Home页面

使用 Layout 分栏布局

`<el-row> 和 <el-col>`来进行组合，一共是24栏，span属性控制占多少栏，gutter属性控制间距



#### el-card

通过 body-style 设置样式

```vue
<el-card
  :body-style="{ padding: '20px 20px 0 20px', height: '200px' }"
  shadow="hover"
>
  <div class="user">
    <img :src="userImg" />
    <div class="userInfo">
      <p class="name">Admin</p>
      <p class="name">超级管理员</p>
    </div>
  </div>
  <div class="login-info">
    <p>上次登陆时间：<span>2022-06-18</span></p>
    <p>上次登陆地点：<span>成都</span></p>
  </div>
</el-card>
```



#### el-table

使用 tableData, tableColumn 等数据进行渲染，注意数据格式



#### Echarts

* 定义图表类型、坐标轴、表头、数据

* 组装成 chartOption
* 获取一个 div 作为echart的容器，通过`echarts.init()`进行初始化
* 通过对该 div 进行 setOption 进行数据赋予



### 用户页面



#### el-dialog

弹出对话框，内部放入 el-form 表单，进行数据输入



#### el-form

* 首先需要传入表单数据对象 model
* 通过 el-form-item 来填入项目进行输入



### 路由管理

主要有四个页面：首页、商品管理、用户管理、其他

因此使用 Vue-router 管理路由，路由模式为hash模式，采取路由懒加载，使用router-view和router-link实现路由的跳转。

获取路由中的数据：`this.$route.params.xxx`，在 details 组件中有用到



### 登陆权限

* 首先在 Router 中创建 login 页面
* 在 store 中创建 token，在登陆时传给后端
* 利用导航守卫 `beforeEach` （会自动跳转到 login 界面）在每个路由进入前获取 token 并校验
  * 校验成功调用 next()
  * 校验失败返回 next({name: "login"})

* 后端根据 username 和 password 进行校验，来返回不同的 menu 和 token
* 在 store 中创建 menu，根据返回的数据进行组装
* 调用 `router.addRoute()` 动态添加路由，把 menu 加进去









# 基础相关



## HTML+CSS 基础

### HTML语义化标签

* html 语义化让页面的**内容结构化，结构更清晰**，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的

* 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，**利于 SEO**

* 使阅读源代码的人对网站更容易将网站分块，**便于团队开发以及维护**

#### 纯语义化标签

* `<header>` 标签表示网页的头部信息，包裹顶部导航栏
* `<nav>` 标签一般表示此部分是导航栏
  * 可以帮助 UA 迅速获得导航内容，例如读屏器可以省去很多渲染直接跳到导航位置
* `<aside>` 标签用来表示跟当前页面的内容没有很相关的部分，通常用于显示侧边栏或者补充的内容
  * 与周围内容关系不太密切的内容 (广告)，通常表现为侧边栏内容 (相关背景内容)、引述内容
* `<article>` 标签用来定义文章的部分
  * 论坛帖子，博客文章，新闻，评论
* `<section>` 标签表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示
* `<footer>` 标签表示章节内容或者是根节点元素中的页脚，包裹网页底部版权信息栏
* `<hgroup>` 主要是将 `<h1>` 到 `<h6>` 之间的子元素组装到一起
  * 文章章节所属多级目录
* `<label>` 标签用于为 `<input>` 元素做标题绑定
* `<caption>` 标签用于定义表格的标题
* `<address>` 标签用于表示提供住址或者联系方式等个人或者组织信息
  * 收货信息、版权信息、联系我们等

#### 语义化标签

* `<progress>`  标签表示进度条。它有一个 `max` 属性来设置进度条的最大值，以及一个 `value` 属性表示当前值
* `<del>` 标签主要是 delete 的意思，即删除部分
* `<ins>` 标签主要是 insert 的意思，即插入部分
* `<noscript>` 标签表示当前浏览器或者其他环境中，如不支持 Javascript 的话，显示的替代内容
* `<figure>`  标签表示一段独立的内容，经常与说明 ` <figcaption>`  进行配合使用
  - 需要有文字说明的图像，表格，代码段等





### CSS 权重

一般为 `!important > style > id > class > tag`

优先级具体算法由四个值来决定：

* A 内联样式
* B ID 选择器
* C 类、伪类、属性选择器
* D 标签选择器和伪元素选择器

举个例子：`#nav-global > ul > li > a.nav-link`

* 因为没有内联样式 ，所以 `A = 0`;

* ID选择器总共出现了1次， `B = 1`;

* 类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 `C = (1 + 0 + 0) = 1`；

* 标签选择器出现了3次， 伪元素出现了0次，所以 `D = (3 + 0) = 3`;

因此可以记为 `(0, 1, 1, 3)`

**比较规则是: **从左往右依次进行比较 ，较大者胜出，如果相等，则继续往右移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的。





### BFC

[学习 BFC ](https://juejin.cn/post/6844903495108132877)

[面试官：请说说什么是BFC？大白话讲清楚](https://juejin.cn/post/6950082193632788493)

`BFC` 全称：`Block Formatting Context`， 名为 "块级格式化上下文"。**是用于决定块盒子的布局及浮动相互影响范围的一个区域**。

简单来说就是，`BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。

#### 触发方式

- **根元素**或其它包含它的元素；
- **浮动** (元素的`float`不为`none`)；
- **绝对定位元素** (元素的`position`为`absolute`或`fixed`)；
- **行内块**`inline-blocks`(元素的 `display: inline-block`)；
- **表格单元格**(元素的`display: table-cell`，HTML表格单元格默认属性)；
- `overflow`的值不为`visible`的元素；
- **弹性盒 flex boxes** (元素的`display: flex`或`inline-flex`)；

但其中，最常见的就是`overflow:hidden`、`float:left/right`、`position:absolute`。也就是说，每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。

#### BFC范围

一个BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。

假如有下面代码，class名为`.BFC`代表创建了新的块格式化：

```html
<div id='div_1' class='BFC'>
    <div id='div_2'>
        <div id='div_3'></div>
        <div id='div_4'></div>
    </div>
    <div id='div_5' class='BFC'>
        <div id='div_6'></div>
        <div id='div_7'></div>
    </div>
</div>
```

这段代码表示，`#div_1`创建了一个块格式上下文，这个上下文包括了`#div_2`、`#div_3`、`#div_4`、`#div_5`。即`#div_2`中的子元素也属于`#div_1`所创建的BFC。但由于`#div_5`创建了新的BFC，所以`#div_6`和`#div_7`就被排除在外层的BFC之外。

这从另一方角度说明，**一个元素不能同时存在于两个BFC中**。

BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

#### BFC特性

* 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；

* 处于同一个BFC中的元素相互影响，可能会发生margin collapse；

* 每个元素的margin box的左边，与容器块border box的左边相接触(对于**从左往右的格式化**，否则相反)。即使存在浮动也是如此；

* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；

* 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；

* 浮动盒区域不叠加到BFC上；

#### 应用

* 闭合浮动：父元素未指定高度，子元素 float 脱离文档流，造成父元素高度塌陷。可以给父元素添加 overflow 形成BFC（特性5、6）；
* 外边距塌陷：属于同一个`BFC`的两个相邻的标签外边距会发生重叠，使其中一个形成 BFC 可以解决（特性2）；
* 两栏布局：一侧 float 脱离文档流，另一侧起初被覆盖（特性3）。给另一侧添加 overflow，形成 BFC（特性6）；







### Flex 布局

#### 原理

弹性布局

* 当为父盒子设置为 flex 布局以后，子元素的 float、clear、vertical-align 失效
* 伸缩布局 = 弹性布局 = flex 布局

采用 Flex 布局的元素，称为“容器”，它的所有**子元素**都会自动成为容器成员，称为“项目”

#### 父项常见属性

* **flex-direction:设置主轴的方向**
  * row 默认从左到右
  * row-reverse 从右到左
  * column 从上到下
  * column-reverse 从下到上
* **justify-content:设置主轴上的子元素排列方式**
  * flex-start 默认值从头部开始，如果主轴是x轴，就从左到右
  * flex-end 从尾部开始
  * center 在主轴居中对齐，如果主轴是x轴，就水平居中
  * space-around 平分剩余空间
  * space-between 先两边贴边，再平分剩余空间
* **flex-wrap:设置子元素是否换行**
  * nowrap 默认不换行
  * wrap 换行
* **align-content:设置侧轴上的子元素的排列方式（多行）**
  * flex-start 默认值，在侧轴的头部开始排列
  * flex-end 在侧轴的尾部开始排列
  * center 在侧轴中间显示
  * space-around 子项在侧轴平分剩余空间
  * space-between 子项在侧轴先分布在两头，再平分剩余空间
  * stretch 设置子项元素高度平分父元素
* **align-items:设置侧轴上的子元素排列方式（单行）**
  * flex-start 从上到下
  * flex-end 从下到上
  * center （聚在一起居中）垂直居中
  * stretch 拉伸（默认值）
* **flex-flow:复合属性，相当于同时设置了flex-direction和flex-wrap**



#### 子项常见属性

* **flex** 子项目占的份数
* **align-self** 控制子项目自己在侧轴的排列方式
  * 可以允许某个单个盒子按照自己的方式在侧轴排列
* **order** 属性定义子项的排列顺序（前后顺序）
  * 数值越小越靠前







### CSS 继承

**字体系列属性**

- font-family：字体系列
- font-weight：字体的粗细
- font-size：字体的大小
- font-style：字体的风格

**文本系列属性**

- text-indent：文本缩进
- text-align：文本水平对齐
- line-height：行高
- word-spacing：单词之间的间距
- letter-spacing：中文或者字母之间的间距
- text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）
- color：文本颜色

**元素可见性**

- visibility：控制元素显示隐藏

**列表布局属性**

- list-style：列表风格，包括list-style-type、list-style-image等

**光标属性**

- cursor：光标显示为何种形态





### **回流和重绘**

* 重排（回流）：无论通过什么方式影响了元素的**几何信息**(元素在视口内的位置和尺寸大小)，浏览器需要**重新计算**元素在视口内的几何属性，这个过程叫做重排。

* 重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的**实际像素**，这个阶段就叫做重绘。（只更改 paint only 属性，例如背景图片、文字颜色、阴影等）

引发回流的因素：

* 添加或删除可见的DOM元素
  * 元素的位置发生变化

* 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）

* 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。

* 页面一开始渲染的时候（这肯定避免不了）

* 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

最小化回流和重绘：

* 比如样式集中改变，使用添加新样式类名 `.class` 或 `cssText` 。

* 批量操作 DOM，比如读取某元素 `offsetWidth` 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 `document.createDocumentFragment()` 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。

* 使用 absolute 或 fixed 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显。

* 开启 GPU 加速，利用 css 属性 `transform` 、`will-change` 等，比如改变元素位置，我们使用 `translate` 会比使用绝对定位改变其 `left` 、`top` 等来的高效，因为它不会触发重排或重绘，`transform` 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。





### **两栏布局**

三种思路：

* 左边脱标，右侧空出左边宽度的距离
* 左边脱标，右侧行成BFC进行隔离（利用BFC和浮动不重叠）
* Flex布局

现在有以下 DOM 结构：

```html
<div class="outer">
  <div class="left">左侧</div>
  <div class="right">右侧</div>
</div>
```

1. 利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 `margin-left` 设为固定宽度 。注意，因为右边元素的 `width` 默认为 `auto` ，所以会自动撑满父元素。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  width: auto;
  height: 100%;
  background: lightseagreen;
}
```

2. 同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 `overflow: hidden;` 这样右边就触发了 `BFC` ，`BFC` 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  overflow: auto;
  height: 100%;
  background: lightseagreen;
}
```

3. 利用 `flex` 布局，左边元素固定宽度，右边的元素设置 `flex: 1` 。

```css
.outer {
  display: flex;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  flex: 1;
  height: 100%;
  background: lightseagreen;
}
```

使用absolute实现的思路和浮动相同





### **圣杯布局**

**方法：**

* 最外侧 container 左右两侧 padding 先空出来左右两侧的距离
* 三个子部分全浮动
* 左边 margin-left:-100% 元素向左偏移直到到上方，再通过相对定位向左位移
* 右边 margin-right:-200px 右侧 margin 向左移动挤压直到上方

HTML 结构：

```html
<div id="container" class="clearfix">
  <p class="center">我是中间</p>
  <p class="left">我是左边</p>
  <p class="right">我是右边</p>
</div>
```

CSS 样式：

```css
#container {
  padding-left: 200px;
  padding-right: 150px;
  overflow: auto;
}
#container p {
  float: left;
}
.center {
  width: 100%;
  background-color: lightcoral;
}
.left {
  width: 200px;
  position: relative;
  left: -200px;
  margin-left: -100%;
  background-color: lightcyan;
}
.right {
  width: 150px;
  margin-right: -150px;
  background-color: lightgreen;
}
.clearfix:after {
  content: "";
  display: table;
  clear: both;
}
```





### **双飞翼布局**

和圣杯的区别是没有最外侧的container

**方法：**

* 单独把main包裹起来，在main内部的div定义左右两侧的margin
* 左侧通过margin-left负值跑上去
* 右侧也使用margin-left负值跑上去

HTML：

```html
  <div id="main" class="float">
    <div id="main-wrap">main</div>
  </div>
  <div id="left" class="float">left</div>
  <div id="right" class="float">right</div>

```

CSS：

```css
.float {
  float: left;
}
#main {
  width: 100%;
  height: 200px;
  background-color: lightpink;
}
#main-wrap {
  margin: 0 190px 0 190px;
}
#left {
  width: 190px;
  height: 200px;
  background-color: lightsalmon;
  margin-left: -100%;
}
#right {
  width: 190px;
  height: 200px;
  background-color: lightskyblue;
  margin-left: -190px;
}
```





### 画三角

* 先给四个 border 都安排厚度
* 修改 width 和 height 为 0
* 将不需要的 border 取消
* 剩下的两个边变透明

```html
<style>
	.triangle{
		/* border-left:50px solid #000; */
		border-right:50px solid transparent;
		border-top:50px solid transparent;
		border-bottom:50px solid #999;
		/* width:100px;
		height:100px; */
        width: 0;
        height: 0;
	}
	</style>
</head>
<body>
	<div class="triangle"></div>
</body>
```

画聊天框左侧小三角的方法：

* 通过伪元素左侧插入一个小三角
* 再插入一个白色小三角，向右偏移 2px

```html
<body>
  <div class="chat-msg">123</div>
</body>

<style>
  .chat-msg {
    width: 300px;
    height: 80px;
    border: 1px solid #ccc;
    position: relative;
  }

  .chat-msg::before {
    content: "";
    position: absolute;
    left: -10px;
    top: 34px;
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    border-right: 10px solid #ccc;
  }

  .chat-msg::after {
    content: "";
    position: absolute;
    left: -8px;
    top: 34px;
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    border-right: 10px solid white;
  }
</style>
```







## 响应式布局方案

[前端响应式布局原理与方案](https://juejin.cn/post/6844903814332432397)

### 媒体查询

针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。

**方案：**

```css
@media not|only mediatype and (mediafeature and|or|not mediafeature) {
	...
}
```

* 媒体类型：
  * all 所有设备
  * screen 电脑屏幕，平板电脑，手机等
  * speech 屏幕阅读器等发声设备
  * print 打印机和打印预览
* 媒体特性：
  * max-width 输出设备中的页面最大可见区域宽度
  * min-width 输出设备中的页面最小可见区域宽度
  * device-height  定义输出设备的屏幕可见高度
  * 等等，具体查询 MDN

举例：

```css
@media only screen and (max-width: 500px) {
    .gridmenu {
        width:100%;
    }

    .gridmain {
        width:100%;
    }

    .gridright {
        width:100%;
    }
}
```

具体分割方案可以参考 Bootstrap



### 百分比布局

通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。

**百分比计算相对父元素：**

* 子元素的`height`或`width`中使用百分比，是相对于子元素的直接父元素，`width`相对于父元素的`width`，`height`相对于父元素的`height`
* 子元素的`top`和`bottom`如果设置百分比，则相对于直接非`static`定位(默认定位)的父元素的高度，同样子元素的`left`和`right`如果设置百分比，则相对于直接非`static`定位(默认定位的)父元素的宽度
* 子元素的`padding`如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的`width`，而与父元素的`height`无关
* 子元素的`margin`如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的`width`

**相对自己：**

* 设置`border-radius`为百分比，则是相对于自身的宽度
* 除了`border-radius`外，还有比如`translate`、`background-size `等都是相对于自身的



### rem 布局

`rem`单位都是相对于根元素html的`font-size`来决定大小，当页面的size发生变化时，只需要改变`font-size`的值，以`rem`为固定单位的元素的大小也会发生相应的变化。 因此，如果通过`rem`来实现响应式的布局，只需要根据视图容器的大小，动态的改变`font-size`即可（而`em`是相对于父元素的）。

**思想：**

* 一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值

* 高度值可以设置固定值，设计稿有多大，我们就严格有多大

* 所有设置的固定值都用`rem`做单位（首先在HTML总设置一个基准值：`px`和`rem`的对应比例，然后在效果图上获取`px`值，布局的时候转化为`rem`值)

* js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了



### 视口单位

`css3`中引入了一个新的单位`vw/vh`，与视图窗口有关，`vw`表示相对于视图窗口的宽度，`vh`表示相对于视图窗口高度，除了`vw`和`vh`外，还有`vmin`和`vmax`两个相关的单位。各个单位具体的含义如下：

| 单位 | 含义                                                      |
| ---- | --------------------------------------------------------- |
| vw   | 相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw |
| vh   | 相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh |
| vmin | vw和vh中的较小值                                          |
| vmax | vw和vh中的较大值                                          |

**任意层级元素**，在使用`vw`单位的情况下，1vw都等于视图宽度的百分之一。







## 前端 SEO 优化

[前端SEO优化](https://juejin.cn/post/6844903824428105735#heading-1)

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a390437d58634345a94274cf59b8c28f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom: 33%;" />

主要思路：

* 对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；
* 网站内容优化：内容与关键字的对应，增加关键字的密度；
* 在网站上合理设置Robots.txt文件；
* 生成针对搜索引擎友好的网站地图；
* 增加外部链接，到各个网站上宣传。

### 网站结构布局优化

尽量简单、开门见山，提倡扁平化结构

* 控制首页链接数量，不能太少（不利于跳转到内页），不能太多（实质性链接少）
* 目录层次扁平化，尽量在 3 次跳转内可达到任何内页
* 导航优化：尽量用文字，可搭配图片，但必须设置 **alt 和 title 属性**，告知搜索引擎定位，尽量加入面包屑，层级明显，增加了内部链接，利于爬虫抓取，降低跳出率
* 网站结构要清晰，分页要清晰
* 控制页面的大小，减少http请求，提高网站的加载速度

### 代码优化

* 标签语义化
  * 比如：h1-h6 是用于标题类
  * 标签是用来设置页面主导航
  * 列表形式的代码使用ul或ol
  * 重要的文字使用strong

* 链接
  * 页内链接加 title
  * 外部链接加 `el="nofollow"` 防止爬出
* 正文标题用 h1 标签
* 重要内容不用 JS 输出
* 尽量少使用 iframe 或者 display: none







## JS 基础



### 数据类型

在 JS 中共有 `8` 种基础的数据类型，分别为： `Undefined` 、 `Null` 、 `Boolean` 、 `Number` 、 `String` 、 `Object` 、 `Symbol` 、 `BigInt` 。

其中 `Symbol` 和 `BigInt` 是 ES6 新增的数据类型，可能会被单独问：

- Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。
- BigInt 可以表示任意大小的整数。

**类型判断**

- **typeof**：能判断所有**值类型(undefined, number, string, boolean, symbol, bigint)，函数**。不可对 **null、对象、数组**进行精确判断，因为都返回 `object` 

```javascript
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```

- **instanceof**：能判断**对象**类型，不能判断基本数据类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。比如考虑以下代码：

```javascript
class People {}
class Student extends People {}

const vortesnail = new Student();

console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true
```

其实现就是顺着**原型链**去找，如果能找到对应的 `Xxxxx.prototype` 即为 `true` 。比如这里的 `vortesnail` 作为实例，顺着原型链能找到 `Student.prototype` 及 `People.prototype` ，所以都为 `true` 。

- **Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等。

```javascript
Object.prototype.toString.call(2); // "[object Number]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(Math); // "[object Math]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"
```






### **手写深拷贝**

* 注意防止循环引用，使用map解决
* 注意判断是数组还是对象

```js
/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 * @param {Map} map 用于存储循环引用对象的地址
 */

function deepClone(obj = {}, map = new Map()) {
  if (typeof obj !== "object") {
    return obj;
  }
  if (map.get(obj)) {
    return map.get(obj);
  }

  let result = {};
  // 初始化返回结果
  if (
    obj instanceof Array ||
    // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此
    Object.prototype.toString(obj) === "[object Array]"
  ) {
    result = [];
  }
  // 防止循环引用
  map.set(obj, result);
  for (const key in obj) {
    // 保证 key 不是原型属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key], map);
    }
  }

  // 返回结果
  return result;
}
```





### 原型和原型链

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom: 50%;" />





### 作用域与作用域链

**JS是静态作用域，即函数的作用域在函数定义时就确定了**

* 作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）

* 作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的**变量对象**构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话）





### 执行上下文

**区分一个概念：执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。**

* 活动对象：活动对象AO和变量对象VO其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问
* 自由变量：既不存在于形参中，也未在作用域内定义的变量

变量对象会包括：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

举例说明:

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

**执行上下文的代码会分为两个步骤处理：分析和执行**

* 分析：给变量对象添加形参、函数声明、变量声明等初始的属性值

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```

* 执行：再次修改属性值

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```



而函数有一个特性，函数有一个内部属性 [[scope]]，<strong style="color:red;">当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链</strong>，但是注意：[[scope]] 并不代表完整的作用域链！

举个例子：

```js
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为：

```js
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```



现在我们把作用域链也加上来分析，举个例子：

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

* 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈

```js
    ECStack = [
        globalContext
    ];
```

* 全局上下文初始化

```js
    globalContext = {
        VO: [global],
        Scope: [globalContext.VO],
        this: globalContext.VO
    }
```

* 初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]

```js
    checkscope.[[scope]] = [
      globalContext.VO
    ];
```

* 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```js
    ECStack = [
        checkscopeContext,
        globalContext
    ];
```

* checkscope 函数执行上下文初始化：
  * 复制函数 [[scope]] 属性创建作用域链<strong style="color:red;">（因为这个复制的过程，在外层函数执行上下文消失后，当前执行上下文Scope变量里仍然保留有活动变量，内存中存在，因此实现了闭包）</strong>
  * 用 arguments 创建活动对象
  * 初始化活动对象，即加入形参、函数声明、变量声明
  * 将活动对象压入 checkscope 作用域链顶端

同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]

```js
    checkscopeContext = {
        AO: {
            arguments: {
                length: 0
            },
            scope: undefined,
            f: reference to function f(){}
        },
        Scope: [AO, globalContext.VO],
        this: undefined
    }
```

* 执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈

```js
    ECStack = [
        fContext,
        checkscopeContext,
        globalContext
    ];
```

* f 函数执行上下文初始化, 以下跟第 4 步相同：
  * 复制函数 [[scope]] 属性创建作用域链
  * 用 arguments 创建活动对象
  * 初始化活动对象，即加入形参、函数声明、变量声明
  * 将活动对象压入 f 作用域链顶端

```js
    fContext = {
        AO: {
            arguments: {
                length: 0
            }
        },
        Scope: [AO, checkscopeContext.AO, globalContext.VO],
        this: undefined
    }
```

* f 函数执行，<strong style="color:red;">沿着作用域链查找 scope 值，返回 scope 值</strong>

* f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

```js
    ECStack = [
        checkscopeContext,
        globalContext
    ];
```

* checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出

```js
    ECStack = [
        globalContext
    ];
```





### call、apply、bind 实现

本质原理解析：

```js
var obj = {
  value: "vortesnail",
};

function fn() {
  console.log(this.value);
}

fn.call(obj); // vortesnail
```

通过 `call` 方法我们做到了以下两点：

- `call` 改变了 this 的指向，指向到 `obj` 。
- `fn` 函数执行了。

那么如果我们自己写 `call` 方法的话，可以怎么做呢？我们先考虑改造 `obj` 。

```javascript
var obj = {
  value: "vortesnail",
  fn: function () {
    console.log(this.value);
  },
};

obj.fn(); // vortesnail
复制代码
```

这时候 this 就指向了 `obj` ，但是这样做我们手动给 `obj` 增加了一个 `fn` 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？

```javascript
obj.fn = fn;
obj.fn();
delete obj.fn;
```

#### call

* 判断调用对象是否为函数
* 获取参数
* 添加方法、调用、删除方法
* 返回值

```js
Function.prototype.myCall = function (context) {
  // 判断调用对象
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  // 首先获取参数
  let args = [...arguments].slice(1);
  let result = null;
  // 判断 context 是否传入，如果没有传就设置为 window
  context = context || window;
  // 将被调用的方法设置为 context 的属性
  // this 即为我们要调用的方法
  context.fn = this;
  // 执行要被调用的方法
  result = context.fn(...args);
  // 删除手动增加的属性方法
  delete context.fn;
  // 将执行结果返回
  return result;
};
```

#### apply

```js
Function.prototype.myApply = function (context) {
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  let result = null;
  context = context || window;
  // 与上面代码相比，我们使用 Symbol 来保证属性唯一
  // 也就是保证不会重写用户自己原来定义在 context 中的同名属性
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  // 执行要被调用的方法
  if (arguments[1]) {
    result = context[fnSymbol](...arguments[1]);
  } else {
    result = context[fnSymbol]();
  }
  delete context[fnSymbol];
  return result;
};
```

#### bind

[解析bind原理](https://github.com/sisterAn/JavaScript-Algorithms/issues/81)

bind 需要返回一个函数

**注意：函数也可以通过 new 初始化，所以在返回时要判断 this 的指向**

```js
Function.prototype.myBind = function (context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  // 获取参数
  const args = [...arguments].slice(1),
  const fn = this;
  return function Fn() {
    return fn.apply(
      this instanceof Fn ? this : context,
      // 当前的这个 arguments 是指 Fn 的参数
      args.concat(...arguments)
    );
  };
};
```





### new实现

* 首先创一个新的空对象。
* 根据原型链，设置空对象的 `__proto__` 为构造函数的 `prototype` 。
* 构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。
* 判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。

```javascript
function myNew(context) {
  const obj = new Object();
  obj.__proto__ = context.prototype;
  const res = context.apply(obj, [...arguments].slice(1));
  return typeof res === "object" ? res : obj;
}
```







### 垃圾回收

#### 策略

有两种垃圾回收策略：

- **标记清除**：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。
- **引用计数**：它把**对象是否不再需要**简化定义为**对象有没有其他对象引用到它**。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。

标记清除优点：

* 算法简单，只需要打个标记

标记清除的缺点：

- **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。
- **分配速度慢**，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:33%;" />

标记清除的优化：

* 使用标记整理算法，将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb543f2fdc634e29add495b8f2ff048f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:33%;" />

引用计数优点：

* 引用计数为0时立即回收，不需要间隔一段时间统一回收

引用计数的缺点：

* 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。
* 解决不了循环引用导致的无法回收问题。





#### V8优化

V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:33%;" />

**新生代回收方式**

* Cheney算法将堆内存一分为二，一个是处于使用状态的空间为使用区，一个是处于闲置状态的空间为空闲区
* 新对象加入到使用区，当使用区快满时对活动对象做标记，复制到空闲区并排序，清理非活动对象
* 空闲区和使用区区域互换
* 多次回收后仍存在的对象存入老生代

**老生代回收方式**

* 采用上述的标记清除法

**优化**

* JS是单线程的，GC一次会出发全停顿，因此V8采用并行回收，开启多个辅助线程帮助回收（老方法）
* 增量标记法：将GC过程切分成小块，交替进行，清理时按需清理（惰性清理）







### 发布订阅模式

* `emit(任务，参数)` 任务分发
* `on(任务，回调函数)` 订阅任务
* `off(任务，回调函数)` 删除任务
* `removeAllListeners(任务)` 删除所有任务

```js
class EventEmitter {
  constructor() {
    this._events = Object.create(null)
  }

  emit(event, args) {
    if (!this._events[event]) return false
    const fns = this._events[event]
    fns.forEach(fn => {
      fn.apply(this, args)
    });
  }

  on(event, fn) {
    if (typeof fn !== "function") {
      throw new TypeError("Must be a function")
    }
    if (!this._events[event]) {
      this._events[event] = [fn]
    } else {
      this._events[event].push(fn)
    }
  }

  off(event, fn) {
    if (this._events[event]) return
    if (!fn) {
      this._events[event] && (this._events[event].length = 0)
    }
    for (let i = 0; i < this._events[event].length; i++) {
      let cb = this._events[event][i]
      if (cb === fn) {
        this._events[event].splice(i, 1)
        break
      }
    }
  }

  removeAllListeners(event) {
    if (event) {
      this._events[event] && (this._events[event].length = 0)
    } else {
      this._events = Object.create(null)
    }
  }
}
```





### 短路运算

- **短路&&**： 只要碰到了假值(false)，就会短路，并返回该假值， 只要短路，不会继续执行后面的表达式。
- **短路||**： 只要碰到了真值(true)，就会短路，并返回该真值， 只要短路，不会继续执行后面的表达式。(一般用作默认值)

**注意：**假值有以下6个  `null` `undefined` `NaN` `false` `0` `''`







## 异步



### 事件循环、宏任务和微任务

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdcea13361a1ec~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:33%;" />

JS是单线程的，但是Web APIs 会创建对应的线程，比如 `setTimeout` 会创建定时器线程，`ajax` 请求会创建 http 线程等，这是由 js 的运行环境决定的，比如浏览器。这些线程在运行时，会通过WebApi或者微任务注册一个回调函数到任务队列中，当这些任务运行结束后，JS会从任务队列中调用回调函数。

因此任务分为宏任务和微任务。

宏任务：setTimeout，setInterval，Ajax，DOM 事件。 微任务：Promise async/await。

两者区别：

- 宏任务：DOM 渲染后触发，如 `setTimeout` 、`setInterval` 、`DOM 事件` 、`script` 。
- 微任务：DOM 渲染前触发，如 `Promise.then` 、`MutationObserver` 、Node 环境下的 `process.nextTick` 。



### Promise

#### 原理及实现

[从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节](https://juejin.cn/post/6945319439772434469#heading-0)

简易版概述：

* 传入函数(`executor(this.resolve, this.reject)`)立即执行
* resolve 函数
  * `status === "PENDING"`
    * 修改状态
    * 修改 value 值供 then 使用
    * 判断成功回调(onFulfilledCallback)是否存在，如果存在就全部调用（异步）
* reject 函数
  * `status === "PENDING"`
    * 修改状态
    * 修改 reason 值供 then 使用
    * 判断失败回调(onRejectedCallback)是否存在，如果存在就全部调用（异步）
* `then(onFulfilled, onRejected)` 函数
  * 外层包裹一个 `let promise2 = new Promise()` 用于链式调用
    * `status === "FULFILLED"` 外层包裹一个微任务(queueMicrotask)等待 promise2 完成初始化
      *  `const x = onFulfilled(this.value)` 缓存执行结果
      *  判断 x 是否为 Promise 对象，如果是，要通过`then`状态改变，不是就 `resolve(x)`

    * `status === "REJECTED"` 外层包裹一个微任务(queueMicrotask)等待 promise2 完成初始化
      *  `const x = onRejectedfilled(this.reason)` 缓存执行结果
      *  判断 x 是否为 Promise 对象，如果是，要通过`then`状态改变，不是就 `resolve(x)`

    * `status === "PENDING"`
      * 数组(onFulfilledCallback)缓存 `onFulfilled` 和 `onRejected` 回调函数<strong style="color:red;">（加入异步逻辑）</strong>
      * 等状态改变后待 resolve or reject 中调用

  * 返回外层包裹的 `Promise`

#### 练习题

[要就来45道Promise面试题一次爽到底](https://juejin.cn/post/6844904077537574919)



#### 常见用法

* `Promise.finally` 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。

```javascript
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```

* `Promise.all()` 用于将多个 Promise 实例，包装成一个新的 Promise 实例
  * `const p = Promise.all([p1, p2, p3]);`
  * 只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数
  * 只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数
  * 以数组形式返回结果
* `Promise.any()` 接收一个数组，只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。

* `Promise.race()` 接收一个数组，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数
* `Promise.resolve()` 将现有对象转为 Promise 对象
  * 如果参数是 Promise 实例，那么`Promise.resolve`将不做任何修改、原封不动地返回这个实例
  * 参数是一个`thenable`对象，将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then()`方法
  * 如果参数是一个原始值，或者是一个不具有`then()`方法的对象，则`Promise.resolve()`方法返回一个新的 Promise 对象，状态为`resolved`
  * 没有任何参数，返回一个`resolved`状态的 Promise 对象

```js
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

* `Promise.reject()` 原理同上





### async / await 原理

[7张图，20分钟就能搞定的async/await原理！为什么要拖那么久？](https://juejin.cn/post/7007031572238958629)

**总结：**基于 `Generator` 实现，通过 `yield` 来进行结果获取，通过 `next(参数)` 进行参数的传递

**基础：**

* 通过星号*来定义 `Generator` ，在内部使用 `yield` 进行停顿，在外部调用 `next()` 来继续进行
* 执行完 `next()` 后状态会改变，具有 `value` 和 `done` 属性
* 在外部通过`next(参数)` 可以进行传参，参数赋予给内部 `yield` 左边的变量

首先写一个基础版本的

```js
function* gen() {
  const num1 = yield fn(1)
  const num2 = yield fn(num1)
  const num3 = yield fn(num2)
  return num3
}

function fn(num) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(num * 2)
    }, 1000)
  })
}

const g = gen()
const next1 = g.next()
next1.value.then((res1) => {
  const next2 = g.next(res1)
  next2.value.then((res2) => {
    const next3 = g.next(res2)
    next3.value.then(res3 => {
      let end = g.next(res3).value
      console.log(end)
    })
  })
})
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8db7c759079a404ebab41b9aacc90c77~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

但是这样有以下几种弊端：

* 无法给外层返回 Promise，获取最后的值

* 并不确定有几个 yield，不确定会嵌套几次

因此使用高阶函数，返回一个 Promise 进行封装，与此同时，在内部定义函数进行递归

* 在 `gen` 函数中实现类似 `await` 的逻辑
* 定义 `fn` 为类似 `async` 的逻辑
* 通过 `generatorToAsync` 实现自动执行，并且停顿
  * 内部先实例化 `generatorFn`
  * 返回一个 Promise，内部定义一个 go 函数用于自动执行
  * 判断是否 done
    * 如果 done，resolve
    * 否则 `Promise.resolve()` 将当前的值传入到下一个 Promise 中，并递归调用 go

```js
function* gen() { 
  const num1 = yield fn(1)
  const num2 = yield fn(num1)
  const num3 = yield fn(num2)
  return num3
}

function fn(num) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(num * 2)
    }, 1000)
  })
}

function generatorToAsync(generatorFn) {
  return function () {
    const gen = generatorFn.apply(this, arguments)
    return new Promise((resolve, reject) => {
      function go(key, arg) {
        let res
        try {
          res = gen[key](arg)
        } catch (err) {
          reject(error)
        }

        const { value, done } = res
        if (done) {
          return resolve(value)
        } else {
          return Promise.resolve(value).then(val => go('next', val), err => go('throw', err))
        }
      }
      go('next')
    })
  }
}

const asyncFn = generatorToAsync(gen)
asyncFn().then(res => console.log(res))
```







## Web存储

[傻傻分不清之 Cookie、Session、Token、JWT](https://juejin.cn/post/6844904034181070861#heading-2)

**http是具有无状态性的**，也就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。

### cookie

* cookie 是一种记录服务器和客户端会话状态的机制
* cookie 存储在客户端，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上
* cookie 是不可跨域的，每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用
* 常用属性：`name=value`键值对、`domain`所属域名、`path`路径、`maxAge`失效时间、`expires`过期时间、`HttpOnly`是否可以通过客户端访问
* 同域名下的请求都会携带 cookie，容易造成性能浪费，但可通过指定 domain 和 path 限定作用域来解决



### session

* session 是一种记录服务器和客户端会话状态的机制
* session 存储在服务端，sessionID 存储在客户端
* 客户端第一次请求，服务端创建 session 并返回 sessionID，之后客户端每次请求携带 sessionID 即可

session可以基于 cookie 实现，具体流程如下：

* 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session

* 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器

* 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名

* 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

当然，也可以通过 url 等其他方式携带 sessionID



### token

* token 是经过哈希算法加密生成的，举个例子：用户名+密码+time+签名经过哈希算法生成一个token
* token 是无状态的，在服务端不需要存储数据，只需要进行解密和签名认证，用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
* token 可以避开同源策略
* token 可以存放于 cookie、localStorage 中，也可以存放在其他请求头中

token 的身份验证流程如下：

* 客户端使用用户名跟密码请求登录
* 服务端收到请求，去验证用户名与密码
* 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
* 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
* 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
* 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d9c745f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom: 50%;" />



### 三者异同

* token 是无状态的，是用于身份验证的凭证，如果要保持一些会话的状态，例如购物车、游戏得分等，则需要 cookie
* 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
* 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
* 有效期不同：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
* 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。



### localStorage 和 sessionStorage

两个存储对象都提供相同的方法和属性：

- `setItem(key, value)` —— 存储键/值对。
- `getItem(key)` —— 按照键获取值。
- `removeItem(key)` —— 删除键及其对应的值。
- `clear()` —— 删除所有数据。
- `key(index)` —— 获取该索引下的键名。
- `length` —— 存储的内容的长度。

#### localStorage

* localStorage 可以用来将数据保存在本地，做数据的持久化，数据不会过期。它在浏览器重启甚至系统重启后仍然存在。
* 在同源的**所有标签页**和窗口之间共享数据。

#### sessionStorage

- sessionStorage 的数据只存在于浏览器**当前标签页**。
  - 具有相同页面的另一个标签页中将会有不同的存储。
  - 但是，它在同一标签页下的 iframe 之间是共享的（假如它们来自相同的源）。
- 数据在页面刷新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留。







## HTTP



### 状态码

- 1xx - 服务器收到请求。
- 2xx - 请求成功，如 200。
- 3xx - 重定向，如 302。
- 4xx - 客户端错误，如 404。
- 5xx - 服务端错误，如 500。

常用状态码：

- 200 - 成功。

- 301 - 永久重定向（配合 location，浏览器自动处理）。

- 302 - 临时重定向（配合 location，浏览器自动处理）。

- 304 - 资源未被修改。

- 403 - 没权限。

- 404 - 资源未找到。

- 500 - 服务器错误。

- 504 - 网关超时。



### http 与 https

HTTP：是互联网上应用最为广泛的一种网络协议，**是一个客户端和服务器端请求和应答的标准（TCP）**，用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即**HTTP下加入SSL层**，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

#### **区别**

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS和HTTP的区别主要如下：

* https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
* http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
* http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
* http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



#### **非对称加密**

* 用公钥加密的数据，只有对应的私钥才能解密

![image-20221025204118480](https://raw.githubusercontent.com/zyy9803/Picture/main/202210252053458.png)

#### 私钥签名

* 同时发送**明文**和经过**hash算法**计算hash值后用**私钥**加密的**密文**
* 收到后对密文使用**公钥**进行解密获取**hash值**，对比使用hash算法计算得到的**明文hash值**

![image-20220425194007826](https://raw.githubusercontent.com/zyy9803/Picture/main/202210252050278.png)

#### **HTTPS 原理**

* 证书机构给浏览器颁发机构公钥，通过机构私钥对服务器信息进行加密，生成服务器证书
* 浏览器发送请求，请求服务器证书
* 服务器响应证书给浏览器，浏览器通过机构公钥进行解密
* 浏览器对请求头进行对称加密(效率高)，发送给服务器
* 服务器解密，告诉浏览器接收成功
* 发送请求报文，接收

![image-20220817112943843](https://raw.githubusercontent.com/zyy9803/Picture/main/202210252050040.png)







### http 1.0、2.0、3.0 

[六张图从HTTP/0.9进化到HTTP3.0](https://juejin.cn/post/6856036933723521032)

#### **http 1.0**

优点：

* 引入了请求头和响应头，请求头加入 User Agent 字段
* 引入了状态码
* 浏览器需指定文件编码类型

瓶颈：

* **不支持多路复用**：每一次HTTP通信都要经过建立TCP、传输数据、断开TCP三个阶段，增加无谓的开销
* **队首阻塞**：只有前面请求返回后才能进行下一次请求，若没有及时返回，则引起队首阻塞
* 不支持断点续传
* 需设置Content-Length，对接收动态生成的内容无能为力





#### http 1.1

优点：

* 增加**长连接**：同一个 TCP 连接上可以传输多个 HTTP 请求
* 对动态生成的内容提供支持：分块传输编码机制
* 引入客户端 Cookie机制和安全机制
* 引入 Etag 缓存（1.0 只支持 If-Modified-Since）

瓶颈：

* 存在**队首阻塞**：一个 TCP 连接同一时刻只能处理一个请求
* TCP 慢启动：关键资源文件不大，但是慢启动会慢慢加快放数据的速度，小文件花费时间也长
* 多条 TCP 连接之间不会协商资源优先级，影响关键资源下载





#### http 2.0

优点：

* **引入二进制帧分层**：HTTP1.X在应用层以纯文本的形式进行通信，HTTP2.0则将所有信息分割为更小的消息和帧，并进行二进制遍码传输
  * 帧：HTTP2.0 通信最小的单位
  * 消息：逻辑上的HTTP消息（请求/响应），一系列数据帧构成了消息
  * 流：数据传输的虚拟信道，每个流有唯一的ID标识符
* **支持多路复用**：利用一个 TCP，并行发送多个请求和响应。将多个请求打散成小的块，混合发送，使得小文件可以被较快的下载，避免大文件引起队首阻塞，即在应用层方面解决了队首阻塞
* 可以设置资源的优先级
* 支持**服务端推送**：支持在未经客户端许可的情况下，主动向客户端推送内容，即单个请求多个返回
* 支持**首部压缩**：1.X 每一次通信都会携带首部信息描述资源属性，2.0 维护一个首部表跟踪和存储之前发送的键值对，在连接中始终存在，不需要每次通信都携带首部



#### http 3.0

优点：

* 基于UDP实现的QUIC协议
* 实现快速握手功能
* 实现类似TCP的流量控制，传输可靠性等功能
* 实现多路复用，解决TCP中队头阻塞问题

缺点：

* 浏览器支持性差
* UDP优化未完善



效果展示：https://http2.akamai.com/demo







### http 缓存

#### 强制缓存

* http 状态码 200
* 失效期结束之前，若服务器资源改变，是无法获取的
* Cache-control:
  * max-age：缓存最大过期时间。
  * no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
  * no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff1ec224244427ba9f15abecbd668fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:33%;" />



#### 协商缓存

- 服务端判断客户端资源，是否和服务端资源一样。
- 一致则返回 304，否则返回 200 和最新的资源和资源标识。
- 资源标识分为两种：
  - If-Modified-Since / Last-Modified：最后修改时间
  - If-None-Match / Etag：资源的唯一标识
- 两种资源标识对比：
  - 优先使用 Etag。
  - Last-Modified 只能精确到秒级。
  - 如果资源被重复生成，而内容不变，则 Etag 更精确。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56e265f46c80430fbf4673878a27bfc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:33%;" />

#### 刷新方式的影响

- 正常操作：地址栏输入 url，跳转链接，前进后退等。
- 手动刷新：f5，点击刷新按钮，右键菜单刷新。
- 强制刷新：ctrl + f5，shift+command+r。

**正常操作：强制缓存有效，协商缓存有效。** **手动刷新：强制缓存失效，协商缓存有效。** **强制刷新：强制缓存失效，协商缓存失效。**





### GET 和 POST

从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。

从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。

从**幂等性**的角度，`GET`是**幂等**的，而`POST`不是。(`幂等`表示执行相同的操作，结果也是相同的)

从**TCP**的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(**火狐**浏览器除外，它的 POST 请求只发一个 TCP 包)







## TCP/IP 和 UDP



### UDP

* 面向无连接
  * 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
  * 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
* 支持单播、多播、广播功能
* UDP是面向报文的
* 不可靠性：体现在无连接上，也不保证数据的完整性
* 头部开销小，传输高效



### TCP/IP

* 面向连接
* 仅支持单播传输
* 面向字节流
* 可靠传输
* 提供拥塞控制
* TCP提供全双工通信



#### 三次握手

TCP 的三次握手，需要确认双方的两样能力: `发送的能力`和`接收的能力`。

* 客户端发起连接，发送 SYN，服务端收到**（客户端的发送能力和服务端的接收能力）**
* 服务端收到后返回 SYN 和 ACK**（服务端的发送能力）**
* 客户端收到后，发送 ACK**（客户端的接收能力）**

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723de9b8aa08b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**两次不行的原因：**无法确认客户端的接收能力



#### 四次挥手

* 刚开始双方都处于 `ESTABLISHED` 状态
* 客户端向服务器发送 `FIN` 报文，客户端变成了`FIN-WAIT-1`状态。注意, 这时候客户端同时也变成了`half-close(半关闭)`状态，即无法向服务端发送报文，只能接收
* 服务端接收后向客户端确认，变成了`CLOSED-WAIT`状态
* 客户端接收到了服务端的确认，变成了`FIN-WAIT2`状态
* 随后，服务端向客户端发送`FIN`，自己进入`LAST-ACK`状态
* 客户端收到服务端发来的`FIN`后，自己变成了`TIME-WAIT`状态，然后发送 ACK 给服务端
* 客户端等待2MSL时长后，若未收到服务端的重发请求，则表示ACK成功到达，结束
  * 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
  * 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723e5c0e05829~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**为什么是四次挥手？三次不行吗？**

因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, 必须等到服务端所有的报文都发送完毕了，才能发`FIN`。因此先发一个`ACK`表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。

如果是三次挥手会有什么问题？

等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。







## 跨域

浏览器同源策略：协议、域名、端口相同

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

### JSONP

`<script>、<img>、<link>、<iframe>` 等标签不存在跨域请求的限制

**思路**

* 在 script 标签中发送请求，同时传入一个本地全局回调函数作为接收 data 的容器
* 服务器收到请求后准备数据，并把数据 JSON 化后传入 func 中，包裹成字符串返回
* 客户端接收到字符串，解析出 func，执行

**特点：**

* 需要服务端支持
* JSONP只能处理 GET 请求

<img src="https://raw.githubusercontent.com/zyy9803/Picture/main/202210252047749.png" alt="image-20220818150929263" style="zoom: 50%;" />

**例子：**

客户端代码：

* jquery 发送 ajax 请求时选择 dataType 为 jsonp
* success 中传入回调函数，jq 会自动帮我们建立全局函数

```js
$.ajax({
  url: 'http://127.0.0.1:8001/list',
  method: 'get',
  dataType: 'jsonp',
  success: res => {
    console.log(res)
  }
})
```

服务端代码：

```js
let express = require('express')
let app = express()

app.listen(8001, () => {
  console.log("ok")
})

app.get('/list', (req, res) => {
  let {
    callback = new Function()
  } = req.query
  let data = {
    code: 0,
    message: 'Candy'
  }

  res.send(`${callback}(${JSON.stringify(data)})`)
})
```





### CORS

CORS（跨源资源共享）通过添加HTTP头信息，**使浏览器判断**是否可以发起跨域访问。

**思路：**

* 简单请求：先请求后判断。GET、POST、HEAD请求，请求头不超出Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type:仅限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
  * 直接发送请求，请求头中携带 Origin 字段
  * 浏览器判断响应头中是否包含 Access-Control-Allow-Origin 字段，如果没有，浏览器就知道服务器是不允许跨域访问的，就会抛出错误
  * 如果包含 Access-Control-Allow-Origin 字段，则同时包含以下字段
    * Access-Control-Allow-Credentials 是否允许发送 Cookie
    * Access-Control-Allow-Headers 允许发送的头信息
    * Access-Control-Allow-Methods 允许使用的方法

* 非简单请求：
  * 先发送预检请求（OPTIONS请求），询问服务器当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP方法和头字段
  * 服务器收到预检请求之后，检查Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段，并做出响应
  * 若符合，则浏览器可以发送正式请求





### postMessage

HTML5新增API，postMessage方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。

`otherWindow.postMessage(message, targetOrigin, [transfer]);`

**思路：**

* 网页 A 

  * postMessage 发送请求

  * window.onmessage 接收返回数据

  * ```js
      frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
      window.onmessage = function(e) { //接受返回数据
      console.log(e.data) //我不爱你
      }
    ```

* 网页 B

  * window.onmessage 接收请求

  * postMessage 返回数据

  * ```js
    // b.html
      window.onmessage = function(e) {
        console.log(e.data) //我爱你
        e.source.postMessage('我不爱你', e.origin)
     }
    ```





### Node.js 中间件代理

原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。**

**思路：**

- 代理服务器接受客户端请求 （代理服务器需配置 CORS 字段）
- 将请求转发给服务器
- 拿到服务器响应数据
- 将响应转发给客户端





### nginx 反向代理

使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

**思路：**

* 通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机
* 反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录







## 首屏优化

[移动商城 SPA 优化](https://juejin.cn/post/6844903577815613453#heading-7)

[Vue 首屏加载速度优化](https://juejin.cn/post/6844904185264095246)

### 打包分析

在 package.json 中添加命令 `"report": "vue-cli-service build --report"`

然后命令行执行 `npm run report`，就会在dist目录下生成一个 report.html 文件，右键浏览器中打开即可看到打包分析报告。

![03.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/435d92c416df457e8d56714b97bccd5b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以看看是哪些文件占用了较大的体积，以及多余的第三方插件和包，进行去除和优化：

* tree-shaking：去除没用过的代码

* UglifyJsPlugin：压缩代码

* ExtractTextPlugin：提取css出来



### 骨架屏

一进页面先加载骨架屏占位，然后再去数据填充。可以使用插件：`vue-skeleton-webpack-plugin`

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/3/19/1623e90f3e86d544~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom: 50%;" />

结合 loading 动画一起使用



### 路由懒加载

在访问到当前页面才会加载相关的资源，异步方式分模块加载文件

```js
{
    path: '/Login',
    name: 'Login',
    component: () = >import( /* webpackChunkName: "Login" */  '@/view/Login')
}
```



### 图片压缩

* 使用 [tinypng]([tinypng.com/](https://link.juejin.cn/?target=https%3A%2F%2Ftinypng.com%2F)) 对图片资源进行压缩，字体图标采用雪碧图

* 使用 `image-webpack-loader`

  * 安装 `npm i image-webpack-loader -D`

  * ```js
    chainWebpack: config => {
      // 压缩图片
      chainWebpack: (config) => {
        if (isProd) {
          // 图片压缩处理
          const imgRule = config.module.rule('images')
          imgRule
            .test(/\.(png|jpe?g|gif|webp)(\?.*)?$/)
            .use('image-webpack-loader')
            .loader('image-webpack-loader')
            .options({ bypassOnDebug: true })
            .end()
        }
    }
    ```



### 开启 gzip 压缩

gizp压缩是一种http请求优化方式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。前端配置gzip压缩，并且服务端使用nginx开启gzip，用来减小网络传输的流量大小。

命令行执行：`npm i compression-webpack-plugin  -D`

在webpack的dev开发配置文件中加入如下代码:

```js
const CompressionWebpackPlugin = require('compression-webpack-plugin')

plugins: [
   new CompressionWebpackPlugin()
]
```



启用gzip压缩打包之后，会变成下面这样，自动生成gz包。目前大部分主流浏览器客户端都是支持gzip的，就算小部分非主流浏览器不支持也不用担心，不支持gzip格式文件的会默认访问源文件的，所以不要配置清除源文件。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/10/1729bfa674cfe417~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

配置好之后，打开浏览器访问线上，F12查看控制台，如果该文件资源的响应头里显示有Content-Encoding: gzip，表示浏览器支持并且启用了Gzip压缩的资源

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/10/1729cd05d097f74c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



### 缓存

* 拆分接口，分批加载填充
* 把不经常变化的数据前端缓存到 localStorage 中，进入页面先从本地拿数据渲染，再动态更新





### 代码层面优化

* 合理使用v-if和v-show
* 合理使用watch和computed
* 使用v-for必须添加key, 最好为唯一id, 避免使用index, 且在同一个标签上，v-for不要和v-if同时使用
* 定时器的销毁。可以在beforeDestroy()生命周期内执行销毁事件；也可以使用$once这个事件侦听器，在定义定时器事件的位置来清除定时器。详细见vue官网







## 文件引入

### link 和 @import

link 的使用

```html
<link href="index.css" rel="stylesheet">
```

@import 的使用

```html
<style type="text/css">
@import url(index.css);
</style>
```

link 和 @import 的区别：

1. 引入的内容不同

   link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件

2. 加载顺序不同

   link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载

3. 兼容性不同

   link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持

4. 对 JS 的支持不同

   link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持



### link用href但script和img用src

src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。

src

- src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素

  ```html
  <script src ="js.js"></script> 
  ```

当浏览器解析到该元素时，**会暂停其他资源的下载和处理**，直到将该资源加载、编译、执行完毕，图片和框架 等元素也如此，类似于将所指向资源嵌入当前标签内。**这也是为什么将js脚本放在底部而不是头部**

href

- href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接

- 在文档中添加link标签，浏览器会识别该文档为css文件，就会并行下载资源并且**不会**停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式

  ```html
  <link href="common.css" rel="stylesheet"/>
  ```



### script、async 和 defer 的区别

- `script` ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- `async script` ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- `defer script`：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。

下图清晰地展示了三种 `script` 的过程：

![](https://raw.githubusercontent.com/zyy9803/Picture/main/202210252050814.awebp)







## 模块化规范

[前端模块化规范详细总结](https://juejin.cn/post/6996595779037036580#heading-0)

模块化解决的问题：

* 解决了命名冲突：因为每个模块是独立的，所以变量或函数名重名不会发生冲突

* 提高可维护性：因为每个文件的职责单一，有利于代码维护

* 性能优化：异步加载模块对页面性能会非常好

* 模块的版本管理：通过别名等配置，配合构建工具，可以实现模块的版本管理

* 跨环境共享模块：通过 Sea.js 的 NodeJS 版本，可以实现模块的跨服务器和浏览器共享

### CommonJS

在每个模块内部有个 module 对象，代表当前模块，用来导出当前模块里的 API，特点：

- 每个文件都是**独立**的模块，有独立的作用域，不会污染全局空间
- 文件可以被重复引用、加载。**第一次加载时会被缓存**，之后再引用就直接读取缓存
- 加载某个模块时，**module.exports 输出的是值的拷贝**，一旦这个值被输出，模块内再发生变化不会影响已经输出的值

导出

```js
module.exports = function(){ ... } // 只能输出一个
或 可以输出多个
exports.a = 1
exports.foo = function(){ ... }
```

exports 可以理解为是 module.exports 的引用，所以上面两种方式结果是一样的。阮一峰老师说过，如果两个不好区分，那就放弃exports，**只用 module.exports 就好**

导入

```js
const foo = require("./xxx") // 如果没有写文件名后缀，会自动按照 .js、.json、.node的顺序补齐查找
```

加载过程如下：

- 先从缓存里找，有就加载
- 缓存没有就检查是不是全局模块，是就直接加载
- 不是就检查模块路径有没有该文件，有就解析路径并定位文件，然后执行加载
- 如果以上都不是，就沿当前路径向上层逐级递归查找，直到根目录 node_modules



### ES6 模块化

CommonJS 是在运行时确定依赖关系，也就是运行时加载，CommonJS 加载的是拷贝，而 ES6 module 是在编译时就确定依赖关系，所有的加载都是引用，这样做的好处是可以执行静态分析和类型检查

ES6 Module 和 CommonJS 的区别：

- `ES6 Module` 的 import 是静态引入，CommonJS的 require 是动态引入
- `ES6 Module` 是对模块的引用，输出的是值的引用，改变原来模块中的值引用的值也会改变；`CommonJS` 是对模块的拷贝，修改原来模块的值不会影响引用的值
- `ES6 Module` 里的 this 指向 undefined；`CommonJS` 里的 this 指向模块本身
- `ES6 Module` 是在编译时确定依赖关系，生成接口并对外输出；CommonJS 是在运行时加载模块
- `ES6 Module` 可以单独加载某个方法；`CommonJS` 是加载整个模块
- `ES6 Module` 不能被重新赋值，会报错；`CommonJS` 可以重新赋值(改变 this 指向)







## 常见手写

### 防抖

```js
function debounce(func, wait) {
  if (typeof func !== 'function') {
    throw TypeError('function is not the type of function')
  }
  let timer = null
  return function () {
    let context = this
    let args = [...arguments]
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      func.apply(context, args)
    }, wait);
  }
}
```





### 节流

```js
function throttle(func, wait) {
  let timer = null
  return function () {
    let context = this
    let args = [...arguments]
    if (!timer) {
      timer = setTimeout(() => {
        func.apply(context, args)
      }, wait)
    }
  }
}
```





### instanceof

```js
function myInstanceof(target, origin) {
  if (typeof target !== "object" || target === null) return false;
  if (typeof origin !== "function")
    throw new TypeError("origin must be function");
  let proto = Object.getPrototypeOf(target); // 相当于 proto = target.__proto__;
  while (proto) {
    if (proto === origin.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```





### 函数柯里化

函数柯里化是指将使用多个参数的函数转化成一系列使用一个参数的函数的技术, 它返回一个新的函数, 这个新函数去处理剩余的参数

* 版本一：参数数量固定 `sum(1,2)(3) || sum(1)(2)(3)`

```js
function curry(fn, arg) {
  let length = fn.length
  let args = arg || []
  return function () {
    args = args.concat([...arguments])
    if (args.length < length) {
      return curry.call(this, fn, args)
    } else {
      return fn.apply(this, args)
    }
  }
}

function sum(a, b, c) {
  return a + b + c
}

let currySum = curry(sum)
console.log(currySum(1, 2)(5))
```

* 版本二：参数数量不固定 `sum(1,2)(3)() || sum(3,4,5,6,7)(8)(9)()`

```js
function curry(fn, arg) {
  let args = arg || []
  return function () {
    args = args.concat([...arguments])
    if (arguments.length !== 0) {
      return curry.call(this, fn, args)
    } else {
      let sum = fn.call(this, 0, args.shift())
      while (args.length) {
        let arg = args.shift()
        sum = fn.call(this, sum, arg)
      }
      return sum
    }
  }
}

function sum(a, b) {
  return a + b
}

let currySum = curry(sum)
console.log(currySum(1, 2)(5, 6)(7)())
```









# Vue



## MVC 和 MVVM

### MVC

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/27/16af72cd60c25062~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:80%;" />

一般`MVC`分为:`Model(模型)`,`View(视图)`,`Controller(控制器)`。 这主要是基于分层的目的,让彼此的职责分开。

* `View`一般用过`Controller`来和`Model`进行联系。
* `Controller`是`Model`和`View`的协调者
* `View`和`Model`不直接联系。基本都是**单向**联系。



### MVVM

`View`的变化会自动更新到`ViewModel`,`ViewModel`的变化也会自动同步到`View上`显示,通过数据来显示视图层。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/27/16af920a988c5f66~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:80%;" />



### 二者区别

**MVVM 与 MVC 最大的区别就是：**它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变

MVVM模式的优点:

- 低耦合:View可以独立于Model变化和修改,一个ViewModel可以绑定到不同的View上,当View变化的时候Model可以不变,当Model变化的时候View也可以不变。
- 可重用性: 可以把一些视图逻辑放在一个ViewModel里面,让很多View重用这段视图逻辑。
- 独立开发: 开发人员可以专注于业务逻辑和数据的开发,设计人员可以专注于页面的设计。

MVVM和MVC的区别:

- MVC中Controller演变成MVVM中的ViewModel
- MVVM通过数据来显示视图层而不是节点操作
- MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验







## 虚拟 DOM

[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589#heading-1)



### 模拟一棵树

生成虚拟 DOM 思路：

* 设置 tagName，props，children
* 循环遍历添加子元素

```js
/**
 * Element virdual-dom 对象定义
 * @param {String} tagName - dom 元素名称
 * @param {Object} props - dom 属性
 * @param {Array<Element|String>} - 子节点
 */
function Element(tagName, props, children) {
    this.tagName = tagName
    this.props = props
    this.children = children
    // dom 元素的 key 值，用作唯一标识符
    if(props.key){
       this.key = props.key
    }
    var count = 0
    children.forEach(function (child, i) {
        if (child instanceof Element) {
            count += child.count
        } else {
            children[i] = '' + child
        }
        count++
    })
    // 子元素个数
    this.count = count
}

function createElement(tagName, props, children){
 return new Element(tagName, props, children);
}

module.exports = createElement;
```

渲染：

* 根据 tagName 进行 createElement
* 通过 setAttribute 设置属性
* 循环遍历 children 生成子元素

```js
/**
 * render 将virdual-dom 对象渲染为实际 DOM 元素
 */
Element.prototype.render = function () {
    var el = document.createElement(this.tagName)
    var props = this.props
    // 设置节点的DOM属性
    for (var propName in props) {
        var propValue = props[propName]
        el.setAttribute(propName, propValue)
    }

    var children = this.children || []
    children.forEach(function (child) {
        var childEl = (child instanceof Element)
            ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点
            : document.createTextNode(child) // 如果字符串，只构建文本节点
        el.appendChild(childEl)
    })
    return el
} 
```



### 比较虚拟 DOM 差异

（1）虚拟 DOM 只会对同一个层级的元素进行对比，如下图所示， `div` 只会和同一层级的 `div` 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 `O(n)`。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/23/16c1e26a5ecf086e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom: 67%;" />

（2）之后进行深度优先遍历新旧两棵树，这样每一个节点都会有一个**唯一的标记**，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面(patches)。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/23/16c1e0e2873e42b1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:67%;" />

（3）`DOM` 操作导致的差异类型包括以下几种：

- 节点替换：节点改变了，例如将上面的 `div` 换成 `h1`;
- 顺序互换：移动、删除、新增子节点，例如上面 `div` 的子节点，把 `p` 和 `ul` 顺序互换；
- 属性更改：修改了节点的属性，例如把上面 `li` 的 `class` 样式类删除；
- 文本改变：改变文本节点的文本内容，例如将上面 `p` 节点的文本内容更改为 “`Real Dom`”；

实际上我们有时不需要进行节点的替换，可以通过**最小编辑距离**算法进行列表移动



### Diff 算法详解

[为什么 Vue 中不要用 index 作为 key？（diff 算法详解）](https://juejin.cn/post/6844904113587634184)



### 总结

* 首先对 DOM 树进行深度优先遍历，生成虚拟 DOM
* 通过 diff 算法比较两个虚拟 DOM 的差异，存入 patches 中
* 根据不同类型的差异对当前节点进行不同的 `DOM` 操作 ，例如如果进行了节点替换，就进行节点替换 `DOM` 操作；如果节点文本发生了改变，则进行文本替换的 `DOM` 操作；以及子节点重排、属性改变等 `DOM` 操作
* 调用 render 方法将虚拟 DOM 转换成真实 DOM 渲染







## 双向数据绑定原理

[0 到 1 掌握：Vue 核心之数据双向绑定](https://juejin.cn/post/6844903903822086151)

通过实现以下 4 个步骤，来实现数据的双向绑定：

* 实现一个监听器 `Observer` ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；
* 实现一个订阅器 `Dep`，用来收集订阅者，对监听器 `Observer` 和 订阅者 `Watcher` 进行统一管理；
* 实现一个订阅者 `Watcher`，可以收到属性的变化通知并执行相应的方法，从而更新视图；
* 实现一个解析器 `Compile`，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。

### Observer

主要通过 `Object.defineProperty(obj, prop, descriptor)` 方法进行数据劫持

**步骤：**

* 遍历对象的每个属性
* 对每个属性进行响应式化

```js
/**
  * 循环遍历数据对象的每个属性
  */
function observable(obj) {
    if (!obj || typeof obj !== 'object') {
        return;
    }
    let keys = Object.keys(obj);
    keys.forEach((key) => {
        defineReactive(obj, key, obj[key])
    })
    return obj;
}
/**
 * 将对象的属性用 Object.defineProperty() 进行设置
 */
function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            return val;
        },
        set(newVal) {
            val = newVal;
        }
    })
}
```



### Dep

每一个属性都需要一个订阅器，当属性发生改变时，订阅了该属性的 Watcher 将收到通知

订阅器结构：

* `addSub` 将 `Watcher` 加入订阅器
* `notify` 分发通知，并调用 Watcher 的 `update`
* `target` **在同一时刻只能有一个全局 Watcher 为 target**

```js
function Dep () {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};
Dep.target = null;
```

**步骤：**

* 改造 defineProperty，在 `set` 时将 `Watcher` 加入订阅器
* 改造 defineProperty，在 `get` 时调用 `notify` 进行分发

```js
defineReactive: function(data, key, val) {
	var dep = new Dep();
	Object.defineProperty(data, key, {
		enumerable: true,
		configurable: true,
		get: function getter () {
			if (Dep.target) {
				dep.addSub(Dep.target);
			}
			return val;
		},
		set: function setter (newVal) {
			if (newVal === val) {
				return;
			}
			val = newVal;
			dep.notify();
		}
	});
}
```



### Watcher

Watcher 有三种：

* 渲染 Watcher，此时 exp 处应传入一个函数，进行所有数据的挂载和渲染
* 计算 Watcher，此时 exp 处是对 DOM 节点进行解析（下面的例子），获取属性值
* 用户自定义的 Watcher

订阅者结构：

* `vm` Vue实例对象
* `exp`  节点的 `v-model` 等指令的属性值或者插值符号中的属性，如 `v-model="name"`，`exp` 就是`name`;
* `cb` 是 `Watcher` 绑定的更新函数
* `value` 将自己添加到订阅器的操作

**步骤：**

* 当实例化 `Watcher` 时（渲染 Watcher 就是数据进行渲染时，计算 Watcher 就是对 DOM 进行解析时，本文用后者举例），调用自身的 `get` 方法
* 修改 `Dep.target` 指向当前 `Watcher`
* 该方法会触发 `data` 上某个属性的 `getter` ，从而把当前渲染 `Watcher` 添加到 `Dep` 中，完成订阅
* 修改 `Dep.target` 为 null

```js
function Watcher(vm, exp, cb) {
    this.vm = vm;
    this.exp = exp;
    this.cb = cb;
    this.value = this.get();  // 将自己添加到订阅器的操作
}

Watcher.prototype = {
    update: function() {
        this.run();
    },
    run: function() {
        var value = this.vm.data[this.exp];
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal);
        }
    },
    get: function() {
        Dep.target = this; // 全局变量 订阅者 赋值
        var value = this.vm.data[this.exp]  // 强制执行监听器里的get函数
        Dep.target = null; // 全局变量 订阅者 释放
        return value;
    }
};
```



### Compile

作 DOM 节点和数据之间的桥梁，本文以 DOM 节点解析时创建计算 Watcher 为例

```js
compileText: function(node, exp) {
	var self = this;
	var initText = this.vm[exp]; // 获取属性值
	this.updateText(node, initText); // dom 更新节点文本值
    // 将这个指令初始化为一个订阅者，后续 exp 改变时，就会触发这个更新回调，从而更新视图
	new Watcher(this.vm, exp, function (value) { 
		self.updateText(node, value);
	});
}
```





### 代理方法

真正的 vue 直接通过 app.name 来访问数据，而我们目前只实现了 app._data.name 来访问，因此需要通过代理方法

**代理方法**，就是要将 app_data 中的成员给映射到 app 上

由于需要在更新数据的时候，更新页面的内容，所以 app._data 访问的成员与 app 访问的成员应该时同一个成员

由于 app._data 已经是响应式的对象了，所以只需要让 app 访问的成员去访问 app.__data 的对应成员就可以了

引入了一个函数 proxy(target, prop, key)，将 target 的操作映射到 target.prop 上，这是因为当时没有 proxy 语法（ES6）

* 首先在 initData 方法中先调用 reactify 编程响应式化
* 再创建 proxy 函数，通过 `return target[prop][key]`将 `this._data[keys[i]]` 映射到 `this[keys[i]]` 上

```js
JGVue.prototype.initData = function () {
      // 将 this._data 的成员转换成响应式，并将其属性代理到实例上
      let keys = Object.keys(this._data)
      for (let i = 0; i < keys.length; i++) {
        // 将对象 this._data[keys[i]] 变成响应式的
        reactify(this._data, this)
      }

      // 代理
      for (let i = 0; i < keys.length; i++) {
        // 将 this._data[keys[i]] 映射到 this[keys[i]] 上
        proxy(this, '_data', keys[i])
      }
    }

    // 将某一个对象的属性访问 映射到 对象的某一个属性成员上
    function proxy(target, prop, key) {
      Object.defineProperty(target, key, {
        enumerable: true,
        configurable: true,
        get() {
          return target[prop][key]
        },
        set(newVal) {
          target[prop][key] = newVal
        }
      })
    }
```







## 数组响应式

Vue 中对以下七种数组方法实现了响应式，主要思路为：

* 根据 Array 原型对象创建新的原型对象
* 在新对象中对七种方法重写，进行响应式化
* 修改数组的原型对象为新对象

```js
<script>
    let ARRAY_METHOD = [
      'push',
      'pop',
      'shift',
      'unshift',
      'reverse',
      'sort',
      'splice',
    ];

    // 思路, 原型式继承: 修改原型链的结构
    let arr = [];
    // 继承关系: arr -> Array.prototype -> Object.prototype -> ...
    // 继承关系: arr -> 改写的方法 -> Array.prototype -> Object.prototype -> ...

    let array_methods = Object.create(Array.prototype);

    ARRAY_METHOD.forEach(method => {
      array_methods[method] = function () {
        // 调用原来的方法
        console.log('调用的是拦截的 ' + method + ' 方法');
        // 将数据进行响应式化
        for (let i = 0; i < arguments.length; i++) {
          reactify(arguments[i]);
        }
        let res = Array.prototype[method].apply(this, arguments);
        // Array.prototype[ method ].call( this, ...arguments ); // 类比
        return res;
      }
    });

    arr.__proto__ = array_methods;

    // Vue 的源码中也做了判断
    // 如果 浏览器支持 __proto__ 那么他就这么做
    // 如果不支持, vue 使用的是混入法

    // arr.length = 0
  </script>
```

但此种方法**不支持**两个操作：

* 直接用索引对数组进行修改，例如：`vm.items[indexOfItem] = newValue`
* 修改数组的长度，例如：`vm.items.length = newLength`

为了解决第一个问题，Vue 提供了以下操作方法：

```scss
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```

为了解决第二个问题，Vue 提供了以下操作方法：

```scss
// Array.prototype.splice
vm.items.splice(newLength)
```





## 生命周期

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca74f183827f46~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:100%;" />





## v-model 原理

v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

- text 和 textarea 元素使用 value 属性和 input 事件；
- checkbox 和 radio 使用 checked 属性和 change 事件；
- select 字段将 value 作为 prop 并将 change 作为事件。

以 input  表单元素为例：

```html
<input v-model='something'>
 相当于
<input v-bind:value="something" v-on:input="something = $event.target.value">
```





## 路由模式

- 单页面应用(`SPA`)的核心之一是: 更新视图而不重新请求页面。
- 路由器对象底层实现的三大步骤即：
  - **监视**地址栏变化。
  - **查找**当前路径对应的页面组件。
  - 将找到的页面组件**替换**到 `router-vieW` 的位置。

### hash 模式

* URL的 hash 也就是锚点 (#), 本质上是改变 `window.location` 的 `href` 属性，虽然它包含在 URL 中，但不包含在 HTTP 请求中
* 我们可以通过直接赋值 `window.location.hash` 来改变 `href` , 但是页面不发生刷新
* 通过 `window.onhashchange = function(){hash 改变时调用该事件}` 进行监听

```js
window.location.href
//'https://juejin.cn/post/6844903918753808398#heading-18'
window.location.href = 'heading-1'
// 实现页面的无刷新改变
window.onhashchange = ()=>{console.log('监听事件')}
```

### history 模式

* 主要基于 `history.pushState()` 和 `history.repalceState()` 实现，可以在不进行刷新的情况下，操作浏览器的历史纪录
* 虽然改变了 URL，但是浏览器不会立即向后端发送请求
* 可以使用 `popstate` 事件来监听 URL 的变化，从而对页面进行跳转（渲染）
* `history.pushState()` 或 `history.replaceState()` 不会触发 `popstate` 事件，这时我们需要手动触发页面跳转（渲染）
* history 模式下有一个问题，就是当页面刷新时，他会实实在在的发送请求，把 URL 给传送过去





## data 为什么是函数

组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果





## 导航守卫

**记得调用 next()**

完整流程：

* 触发进入其他路由。
* 调用要离开路由的组件守卫`beforeRouteLeave`
* 调用全局前置守卫：`beforeEach`
* 在重用的组件里调用 `beforeRouteUpdate`
* 调用路由独享守卫 `beforeEnter`。
* 解析异步路由组件。
* 在将要进入的路由组件中调用`beforeRouteEnter`
* 调用全局解析守卫 `beforeResolve`
* 导航被确认。
* 调用全局后置钩子的 `afterEach` 钩子。
* 触发DOM更新(`mounted`)。
* 执行`beforeRouteEnter` 守卫中传给 next 的回调函数



### 全局守卫

可以在 main.js 中配置

* `router.beforeEach` 全局前置守卫，进入路由之前
* `router.beforeResolve` 全局解析守卫(2.5.0+) 在 `beforeRouteEnter` 调用之后调用
* `router.afterEach` 全局后置守卫，进入路由之后

```js
    // main.js 入口文件
    import router from './router'; // 引入路由
    router.beforeEach((to, from, next) => { 
      next();
    });
    router.beforeResolve((to, from, next) => {
      next();
    });
    router.afterEach((to, from) => {
      console.log('afterEach 全局后置钩子');
    });
```

### 路由独享守卫

在 `routes` 中对响应路径进行配置

```js
    const router = new VueRouter({
      routes: [
        {
          path: '/foo',
          component: Foo,
          beforeEnter: (to, from, next) => { 
            // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖
            // ...
          }
        }
      ]
    })
```

### 组件内守卫

在组件内调用钩子

* `beforeRouteEnter` 进入路由之前
* `beforeRouteUpdate` 复用组件时候
* `beforeRouteLeave` 离开当前路由时





## 组件通信

* `props` 父组件向子组件传值，子组件不能修改，若要修改需要使用 Computed 
* `props.sync` 父组件向子组件传值，子组件可以修改，修改时影响父组件数据
* `ref` 如果在普通的DOM元素上，引用指向的就是该DOM元素，如果在子组件上，引用的指向就是子组件实例，然后父组件就可以通过 ref 主动获取子组件的属性或者调用子组件的方法

```vue
// Parent.vue
<template>
    <child ref="child"></child>
</template>
<script>
export default {
    mounted(){
        const child = this.$refs.child
        console.log(child.name) // 沐华
        child.someMethod("调用了子组件的方法")
    }
}
</script>
```

* `$emit / v-on` 子组件通过自定义事件向父组件传值
* `$attrs / $listeners` 多层嵌套组件传递数据时，如果只是传递数据，而不做中间处理的话就可以用这个，比如父组件向孙子组件传递数据时
  * `$attrs`：包含父作用域里除 class 和 style 除外的非 props **属性集合**。通过 this.$attrs 获取父作用域中所有符合条件的属性集合，然后还要继续传给子组件内部的其他组件，就可以通过 v-bind="$attrs"
  * `$listeners`：包含父作用域里 .native 除外的监听**事件集合**。如果还要继续传给子组件内部的其他组件，就可以通过 v-on="$linteners"

```vue
// Parent.vue
<template>
    <child :name="name" title="1111" ></child>
</template>
export default{
    data(){
        return {
            name:"沐华"
        }
    }
}

// Child.vue
<template>
    // 继续传给孙子组件
    <sun-child v-bind="$attrs"></sun-child>
</template>
export default{
    props:["name"], // 这里可以接收，也可以不接收
    mounted(){
        // 如果props接收了name 就是 { title:1111 }，否则就是{ name:"沐华", title:1111 }
        console.log(this.$attrs)
    }
}
```

* `$children / $parent`
  * `$children`：获取到一个包含所有子组件(不包含孙子组件)的 VueComponent 对象数组，可以直接拿到子组件中所有数据和方法等
  * `$parent`：获取到一个父节点的 VueComponent 对象，同样包含父节点中所有数据和方法等

```js
// Parent.vue
export default{
    mounted(){
        this.$children[0].someMethod() // 调用第一个子组件的方法
        this.$children[0].name // 获取第一个子组件中的属性
    }
}

// Child.vue
export default{
    mounted(){
        this.$parent.someMethod() // 调用父组件的方法
        this.$parent.name // 获取父组件中的属性
    }
}
```

* `$bus` 当涉及到非父子组件之间的通信时，需要用到事件总线进行跨层级通信
  * 在main.js文件中`Vue.prototype.$bus = new Vue()`
  * `this.$bus.$emit('事件名称',参数)`
  * `this.$bus.$on('事件名称',回调函数(参数))`

* `Vuex` 状态管理





## 插件使用

* 首先写好 `.vue` 文件

```vue
<template>
  <transition name="toast-fade">
    <div v-show="visible" class="c-toast" :class="positionClass">
      {{ message }}
    </div>
  </transition>
</template>
<script>
export default {
  name: "CToast",
  data() {
    return {
      visible: false,
      position: "center",
      duration: 150000,
      message: "",
    };
  },
  computed: {
    positionClass() {
      return "c-toast" + this.position;
    },
  },
};
</script>
<style lang="less">
省略
</style>
```

* 创建 一个 `index.js` 引入刚才的 vue 组件
* 创建一个对象，其内部有一个 `install(Vue,opstions)` 方法
  * 当调用 `Vue.use` 指令时会调用 install 方法
  * 传入 Vue 实例和 options 作为参数
  * 使用 Vue.extend 根据 Vue 组件创建一个组件构造器
  * 使用构造器传入参数构造实例
  * 通过 `$mount` 方法挂载到文档中

```js
import TempToast from './CToast'

let showToast = false
let time

const cToast = {
  install(Vue, options) {
    let opt = TempToast.data()

    Vue.prototype.$cToast = (message, position) => {
      // 清除之前的定时器
      if (showToast) {
        clearTimeout(time)
        instance.vm.visible = showToast = false
        document.body.removeChild(instance.vm.$el)
      }

      // 根据传入的值修改 message 和 position
      if (message) {
        opt.message = message
      }
      if (position) {
        opt.position = position
      }

      // 创建一个子类
      const TempToastConstructor = Vue.extend(TempToast)
      // 将子类实例化，并传入新的 data 数据
      let instance = new TempToastConstructor({
        data: opt
      })
      // 将实例挂载在到 body 上，如果 $mount 没有传参，模板将被渲染为文档之外的的元素，必须使用原生 DOM API 把它插入文档中
      instance.vm = instance.$mount()
      document.body.appendChild(instance.vm.$el)


      // 设定定时器
      time = setTimeout(function () {
        instance.vm.visible = showToast = false
        document.body.removeChild(instance.vm.$el)
      }, opt.duration)
    }
  }
}

export default cToast
```







## 自定义指令



### 钩子函数

- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。

- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
- `unbind`：只调用一次，指令与元素解绑时调用。



### 钩子函数参数

- `el`：指令所绑定的元素，可以用来直接操作 DOM。
- `binding`：一个对象，包含以下 property：
  - `name`：指令名，不包括 `v-` 前缀。
  - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`。
  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。
  - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。
  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。
- `vnode`：Vue 编译生成的虚拟节点。
- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。



### 使用方法

* 创建一个对象，包含上述的钩子方法

```js
const focus = {
  inserted: function (el) {
    el.focus()
  }
}
export default focus
```

* 使用 `Vue.directive('focus', focus)` 注册全局指令
* 在元素中使用 `<input v-focus>`



### 案例

#### v-debounce

防抖指令

* 创建对象，在 `inserted` 时引入，在 `unbind` 移除事件

```js
const debounce = {
  inserted: function (el, binding) {
    if (typeof binding.value !== 'function') {
      throw new Error("must be a function")
    }
    let timer = null
    el.addEventListener('click', () => {
      if (timer) {
        clearTimeout(timer)
      }
      timer = setTimeout(() => {
        binding.value()
      }, 1000)
    })

  },

  unbind: function (el) {
    el.removeEventListener('click')
  }
}

export default debounce
```

* 创建一个插件，通过 `Vue.use` 使用该插件，在插件中进行 `Vue.directive`

```js
import copy from './copy'
import focus from './focus'
import debounce from './debounce'

const directives = {
  copy,
  focus,
  debounce
}

export default {
  install(Vue) {
    Object.keys(directives).forEach((key) => {
      Vue.directive(key, directives[key])
    })
  }
}
```



#### v-lazyload

实现图片的懒加载

* 利用 `data-src` 做了一层数据转移
* 图片位于窗口内时，讲 `data-src` 中的 `src` 赋予图片，移除 `data-src` 属性

```js
const LazyLoad = {
  // install方法
  install(Vue, options) {
    const defaultSrc = options.default
    Vue.directive('lazy', {
      bind(el, binding) {
        LazyLoad.init(el, binding.value, defaultSrc)
      },
      inserted(el) {
        if (IntersectionObserver) {
          LazyLoad.observe(el)
        } else {
          LazyLoad.listenerScroll(el)
        }
      },
    })
  },
  // 初始化
  init(el, val, def) {
    el.setAttribute('data-src', val)
    el.setAttribute('src', def)
  },
  // 利用IntersectionObserver监听el
  observe(el) {
    var io = new IntersectionObserver((entries) => {
      const realSrc = el.dataset.src
      if (entries[0].isIntersecting) {
        if (realSrc) {
          el.src = realSrc
          el.removeAttribute('data-src')
        }
      }
    })
    io.observe(el)
  },
  // 监听scroll事件
  listenerScroll(el) {
    const handler = LazyLoad.throttle(LazyLoad.load, 300)
    LazyLoad.load(el)
    window.addEventListener('scroll', () => {
      handler(el)
    })
  },
  // 加载真实图片
  load(el) {
    const windowHeight = document.documentElement.clientHeight
    const elTop = el.getBoundingClientRect().top
    const elBtm = el.getBoundingClientRect().bottom
    const realSrc = el.dataset.src
    if (elTop - windowHeight < 0 && elBtm > 0) {
      if (realSrc) {
        el.src = realSrc
        el.removeAttribute('data-src')
      }
    }
  },
  // 节流
  throttle(fn, delay) {
    let timer
    let prevTime
    return function (...args) {
      const currTime = Date.now()
      const context = this
      if (!prevTime) prevTime = currTime
      clearTimeout(timer)

      if (currTime - prevTime > delay) {
        prevTime = currTime
        fn.apply(context, args)
        clearTimeout(timer)
        return
      }

      timer = setTimeout(function () {
        prevTime = Date.now()
        timer = null
        fn.apply(context, args)
      }, delay)
    }
  },
}

export default LazyLoad
```





## Mixin

### 使用方法

* 创建 `mixin` 文件夹，在 `index.js` 文件中创建一个 `mixin` 对象，里面可以包含组件的各种钩子、数据及方法

```js
export const mixins = {
  data() {
    return {
      msg: "hello world"
    }
  },
  computed: {

  },
  created() {
    console.log("created in mixin")
  },
  mounted() {
    console.log("mounted in mixin")
  },
  methods: {
    clickMe() {
      console.log(this.msg)
    }
  },
}
```

* 局部混入，可以调用 `mixin` 中的数据和方法，钩子函数先调用 `mixin` 中的，再调用组件的

```vue
// src/App.vue
<template>
  <div id="app">
    <img alt="Vue logo" src="./assets/logo.png" />
    <button @click="clickMe">点击我</button>
  </div>
</template>

<script>
import { mixins } from "./mixin/index";
export default {
  name: "App",
  mixins: [mixins],
  components: {},
  created(){
    console.log("组件调用minxi数据",this.msg);
  },
  mounted(){
    console.log("我是组件的mounted生命周期函数")
  }
};
</script>
```

* 全局混入，这样会导致每个组件生命周期都会调用 `mixin` 中的，不建议使用

```js
import Vue from "vue";
import App from "./App.vue";
import { mixins } from "./mixin/index";
Vue.mixin(mixins);

Vue.config.productionTip = false;

new Vue({
  render: (h) => h(App),
}).$mount("#app");
```

### 选项合并

无论是 `data` 还是 `methods` ，都是组件内会覆盖 `mixin` 中的 







## 过滤器

Vue过滤器本质上是一个函数，它接受一个值，处理它，然后返回处理过的值。

过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道 ( | ) ”符号指示：

```xml
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

你可以在一个组件的选项中定义本地的过滤器：

```scss
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```

或者在创建 Vue 实例之前全局定义过滤器：

```javascript
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```

过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数。

过滤器可以串联：

```
{{ message | filterA | filterB }}
```

在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。

过滤器是 JavaScript 函数，因此可以接收参数：

```scss
{{ message | filterA('arg1', arg2) }}
```

这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。





## nextTick

[从Vue.js源码看异步更新DOM策略及nextTick](https://juejin.cn/post/6844903497649881096)

[nextTick实现原理，必拿下!](https://juejin.cn/post/7087866362785169416)

**出现的原因**：Vue 采用**异步更新策略**，当监听到数据发生变化时不去立即更新DOM，而是开启一个任务队列，缓存在同一事件循环中发生的所有数据变更，这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作DOM的次数。

**作用：**nextTick 接收一个回调函数作为参数，并将这个回调函数延迟到DOM更新后才执行

**原理：**

* 将回调函数 cb 压入 callbacks 数组中，判断 cb 是否有值
* 判断当前是否有回调处于 pending 状态，调用 timerFunc()
* timerFunc 逻辑如下：*Promise---> MutationObserver---> setImmediate---> setTimeout*
  * 环境是否支持上述的任务，如果支持，就把 flushCallbacks 函数放入异步逻辑中
  * flushCallbacks 函数逻辑：
    * 修改 pending 为 false，使下个事件循环中 nextTick 函数可以调用 timerFunc
    * 把 callbacks 数组中所有回调取出来执行

```js
import { noop } from 'shared/util'
import { handleError } from './error'
import { isIE, isIOS, isNative } from './env'

//  上面三行与核心代码关系不大，了解即可
//  noop 表示一个无操作空函数，用作函数默认值，防止传入 undefined 导致报错
//  handleError 错误处理函数
//  isIE, isIOS, isNative 环境判断函数，
//  isNative 判断某个属性或方法是否原生支持，如果不支持或通过第三方实现支持都会返回 false


export let isUsingMicroTask = false     // 标记 nextTick 最终是否以微任务执行

const callbacks = []     // 存放调用 nextTick 时传入的回调函数
let pending = false     // 标记是否已经向任务队列中添加了一个任务，如果已经添加了就不能再添加了
    // 当向任务队列中添加了任务时，将 pending 置为 true，当任务被执行时将 pending 置为 false
    // 


// 声明 nextTick 函数，接收一个回调函数和一个执行上下文作为参数
// 回调的 this 自动绑定到调用它的实例上
export function nextTick(cb?: Function, ctx?: Object) {
    let _resolve
    // 将传入的回调函数存放到数组中，后面会遍历执行其中的回调
    callbacks.push(() => {
        if (cb) {   // 对传入的回调进行 try catch 错误捕获
            try {
                cb.call(ctx)
            } catch (e) {    // 进行统一的错误处理
                handleError(e, ctx, 'nextTick')
            }
        } else if (_resolve) {
            _resolve(ctx)
        }
    })
    
    // 如果当前没有在 pending 的回调，
    // 就执行 timeFunc 函数选择当前环境优先支持的异步方法
    if (!pending) {
        pending = true
        timerFunc()
    }
    
    // 如果没有传入回调，并且当前环境支持 promise，就返回一个 promise
    // 在返回的这个 promise.then 中 DOM 已经更新好了，
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(resolve => {
            _resolve = resolve
        })
    }
}


// 判断当前环境优先支持的异步方法，优先选择微任务
// 优先级：Promise---> MutationObserver---> setImmediate---> setTimeout
// setTimeout 可能产生一个 4ms 的延迟，而 setImmediate 会在主线程执行完后立刻执行
// setImmediate 在 IE10 和 node 中支持

// 当在同一轮事件循环中多次调用 nextTick 时 ,timerFunc 只会执行一次

let timerFunc   
// 判断当前环境是否原生支持 promise
if (typeof Promise !== 'undefined' && isNative(Promise)) {  // 支持 promise
    const p = Promise.resolve()
    timerFunc = () => {
    // 用 promise.then 把 flushCallbacks 函数包裹成一个异步微任务
        p.then(flushCallbacks)
        if (isIOS) setTimeout(noop)
    }
    // 标记当前 nextTick 使用的微任务
    isUsingMicroTask = true
    
    
    // 如果不支持 promise，就判断是否支持 MutationObserver
    // 不是IE环境，并且原生支持 MutationObserver，那也是一个微任务
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
    let counter = 1
    // new 一个 MutationObserver 类
    const observer = new MutationObserver(flushCallbacks) 
    // 创建一个文本节点
    const textNode = document.createTextNode(String(counter))   
    // 监听这个文本节点，当数据发生变化就执行 flushCallbacks 
    observer.observe(textNode, { characterData: true })
    timerFunc = () => {
        counter = (counter + 1) % 2
        textNode.data = String(counter)  // 数据更新
    }
    isUsingMicroTask = true    // 标记当前 nextTick 使用的微任务
    
    
    // 判断当前环境是否原生支持 setImmediate
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    timerFunc = () => { setImmediate(flushCallbacks)  }
} else {

    // 以上三种都不支持就选择 setTimeout
    timerFunc = () => { setTimeout(flushCallbacks, 0) }
}


// 如果多次调用 nextTick，会依次执行上面的方法，将 nextTick 的回调放在 callbacks 数组中
// 最后通过 flushCallbacks 函数遍历 callbacks 数组的拷贝并执行其中的回调
function flushCallbacks() {
    pending = false    
    const copies = callbacks.slice(0)    // 拷贝一份 callbacks
    callbacks.length = 0    // 清空 callbacks
    for (let i = 0; i < copies.length; i++) {    // 遍历执行传入的回调
        copies[i]()
    }
}

// 为什么要拷贝一份 callbacks

// 用 callbacks.slice(0) 将 callbacks 拷贝出来一份，
// 是因为考虑到在 nextTick 回调中可能还会调用 nextTick 的情况,
// 如果在 nextTick 回调中又调用了一次 nextTick，则又会向 callbacks 中添加回调，
// 而 nextTick 回调中的 nextTick 应该放在下一轮执行，
// 否则就可能出现一直循环的情况，
// 所以需要将 callbacks 复制一份出来然后清空，再遍历备份列表执行回调

作者：大古Zio
链接：https://juejin.cn/post/7087866362785169416
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







# Webpack

作用：模块打包、编译兼容、能力扩展

## 打包原理

[[手写一个webpack，看看AST怎么用](https://segmentfault.com/a/1190000039231950)](https://segmentfault.com/a/1190000039231950)

流程：

* 读取`webpack`的配置参数
* 启动`webpack`，创建`Compiler`对象并开始解析项目
* 从入口文件（`entry`）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树
* 对不同文件类型的依赖模块文件使用对应的`Loader`进行编译，最终转为`Javascript`文件
* 整个过程中`webpack`会通过发布订阅模式，向外抛出一些`hooks`，而`webpack`的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。

代码层面流程：

* `__webpack_modules__ `对象存了所有的模块代码
* 将`import`这种浏览器不认识的关键字替换成了 `__webpack_require__` 函数调用
* `__webpack_require__`其实就是用来加载模块的，实现流程：
  * 定义一个变量`__webpack_module_cache__`作为加载了的模块的缓存
  * 加载模块时，先检查缓存中有没有，如果有，就直接返回缓存
  * 如果缓存没有，就从`__webpack_modules__`将对应的模块取出来执行
  * 每个模块执行除了执行我们的逻辑外，还会将`export`的内容添加到`module.exports`上，这就是前面说的`__webpack_require__.d`辅助方法的作用。添加到`module.exports`上其实就是添加到了`__webpack_module_cache__`缓存上，后面再引用这个模块就直接从缓存拿了



## 常见问题



### 常见 Loader

* `file-loader`：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)

* `url-loader`：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
* `source-map-loader`：加载额外的 Source Map 文件，以方便断点调试
* `image-loader`：加载并且压缩图片文件
* `json-loader` 加载 JSON 文件（默认包含）
* `babel-loader`：把 ES6 转换成 ES5
* `sass-loader`：将SCSS/SASS代码转换成CSS
* `css-loader`：加载 CSS，支持模块化、压缩、文件导入等特性
* `style-loader`：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
* `eslint-loader`：通过 ESLint 检查 JavaScript 代码
* `vue-loader`：加载 Vue.js 单文件组件
* `cache-loader`: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里



### 常见 Plugin

* `ignore-plugin`：忽略部分文件

* `html-webpack-plugin`：简化 HTML 文件创建 (依赖于 html-loader)

* `web-webpack-plugin`：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用

* `webpack-parallel-uglify-plugin`: 多进程执行代码压缩，提升构建速度

* `mini-css-extract-plugin`: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)



### Loader 和 Plugin 的区别

* `Loader` 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

* `Plugin` 就是插件，基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

* `Loader` 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

* `Plugin` 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。




### 构建流程

* `初始化参数`：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数

* `开始编译`：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译

* `确定入口`：根据配置中的 entry 找出所有的入口文件

* `编译模块`：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理

* `完成模块编译`：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系

* `输出资源`：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会

* `输出完成`：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统



### Source Map

`source map` 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。

* 使用方法：添加 `devtool: 'eval-source-map'`

`[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map`

map文件只要不打开开发者工具，浏览器是不会加载的。

线上环境一般有三种处理方案：

- `hidden-source-map`：借助第三方错误监控平台 Sentry 使用
- `nosources-source-map`：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高
- `sourcemap`：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)

注意：避免在生产中使用 `inline-` 和 `eval-`，因为它们会增加 bundle 体积大小，并降低整体性能。



### HMR 原理

`Webpack` 的热更新又称热替换（`Hot Module Replacement`），缩写为 `HMR`。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。

HMR的核心就是客户端从服务端拉取更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 `Websocket`，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 `Ajax` 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 `jsonp` 请求获取该chunk的增量更新。

后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 `HotModulePlugin` 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像`react-hot-loader` 和 `vue-loader` 都是借助这些 API 实现 HMR。







# Git



## 工作区

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec7210655b4d4fc4afcd1466d9aa2343~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

* Workspace：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作

* Index：暂存区，当执行 `git add` 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中那些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 `git add` 先提交到暂存区。

* Repository：本地仓库，位于自己的电脑上，通过 `git commit` 提交暂存区的内容，会进入本地仓库。

* Remote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 `git push` 命令同步代码到远程仓库。



## 常用操作

### git init

初始化

### git config

```bash
# 项目级别/仓库级别：仅在当前本地库范围内有效
git config user.name candy
git config user.email zyy9803@foxmail.com
# 信息保存位置 `.git/config` 文件中，可以通过 `cat .git/cofig` 命令查询
# 系统用户级别：登陆当前操作系统的用户范围
git config --global user.name candy
git config --global user.email zyy9803@foxmail.com
# 信息保存位置 `~/.gitconfig` 文件中，可以通过 `cd ~` 进入~目录 `cat .git/cofig` 命令查询
```

### git status

查看状态

### git log

查看提交状态

```bash
git log --pretty=oneline 简洁一些
git log --oneline 更简洁
git reflog 在上一个基础上显示了 HEAD@{移动到当前版本需要多少步}
```

### git add

添加文件到暂存区

```bash
# 添加某个文件到暂存区，后面可以跟多个文件，以空格区分
git add xxx
# 添加当前更改的所有文件到暂存区。
git add .
```

### git commit

提交暂存区里的修改

```bash
# 提交暂存的更改，会新开编辑器进行编辑
git commit 
# 提交暂存的更改，并记录下备注
git commit -m "you message"
# 等同于 git add . && git commit -m
git commit -am
# 对最近一次的提交的信息进行修改,此操作会修改commit的hash值
git commit --amend
```

### git reset

通过 head 指针控制版本前进后退

* 通过索引值 `git reset --hard 局部索引值`，索引值通过 git log 查看

![image-20220427194558100](https://raw.githubusercontent.com/zyy9803/Picture/main/202210252049228.png)

* 使用 ^ 符号：`git reset --hard HEAD^^^`只能后退，几个 ^ 后退几步
* 使用 ~ 符号：`git reset --hard HEAD~5`只能后退，后退 n 步

参数含义：

* --soft 参数：仅仅在本地库移动 head 指针
* --mixed 参数：在本地库移动 head 指针，重置暂存区
* --hard 参数：在本地库移动 head 指针，重置暂存区，重置工作区

### git pull

从远程仓库拉取代码并合并到本地

```bash
# 从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch && git merge 
git pull <远程主机名> <远程分支名>:<本地分支名>
# 使用rebase的模式进行合并
git pull --rebase <远程主机名> <远程分支名>:<本地分支名>
```

### git fetch

与 `git pull` 不同的是 `git fetch` 操作仅仅只会拉取远程的更改，不会自动进行 merge 操作。对你当前的代码没有影响

```bash
# 获取远程仓库特定分支的更新
git fetch <远程主机名> <分支名>
# 获取远程仓库所有分支的更新
git fetch --all
```

### git branch

```bash
# 新建本地分支，但不切换
git branch <branch-name> 
# 查看本地分支
git branch
# 查看远程分支
git branch -r
# 查看本地和远程分支
git branch -a
# 删除本地分支
git branch -D <branch-nane>
# 重新命名分支
git branch -m <old-branch-name> <new-branch-name>
```







# 杂



## Axios 拦截器

**请求拦截**

我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。

```js
// 先导入vuex,因为我们要使用到里面的状态对象
// vuex的路径根据自己的路径去写
import store from '@/store/index';

// 请求拦截器
axios.interceptors.request.use(    
    config => {        
        // 每次发送请求之前判断vuex中是否存在token        
        // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况
        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 
        const token = store.state.token;        
        token && (config.headers.Authorization = token);        
        return config;    
    },    
    error => {        
        return Promise.error(error);    
})
```

**响应拦截**

```js
// 响应拦截器
axios.interceptors.response.use(    
    response => {   
        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据     
        // 否则的话抛出错误
        if (response.status === 200) {            
            return Promise.resolve(response);        
        } else {            
            return Promise.reject(response);        
        }    
    },    
    // 服务器状态码不是2开头的的情况
    // 这里可以跟你们的后台开发人员协商好统一的错误状态码    
    // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等
    // 下面列举几个常见的操作，其他需求可自行扩展
    error => {            
        if (error.response.status) {            
            switch (error.response.status) {                
                // 401: 未登录
                // 未登录则跳转登录页面，并携带当前页面的路径
                // 在登录成功后返回当前页面，这一步需要在登录页操作。                
                case 401:                    
                    router.replace({                        
                        path: '/login',                        
                        query: { 
                            redirect: router.currentRoute.fullPath 
                        }
                    });
                    break;

                // 403 token过期
                // 登录过期对用户进行提示
                // 清除本地token和清空vuex中token对象
                // 跳转登录页面                
                case 403:
                     Toast({
                        message: '登录过期，请重新登录',
                        duration: 1000,
                        forbidClick: true
                    });
                    // 清除token
                    localStorage.removeItem('token');
                    store.commit('loginSuccess', null);
                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 
                    setTimeout(() => {                        
                        router.replace({                            
                            path: '/login',                            
                            query: { 
                                redirect: router.currentRoute.fullPath 
                            }                        
                        });                    
                    }, 1000);                    
                    break; 

                // 404请求不存在
                case 404:
                    Toast({
                        message: '网络请求不存在',
                        duration: 1500,
                        forbidClick: true
                    });
                    break;
                // 其他错误，直接抛出错误提示
                default:
                    Toast({
                        message: error.response.data.message,
                        duration: 1500,
                        forbidClick: true
                    });
            }
            return Promise.reject(error.response);
        }
    }    
});
```





## XSS 和 CSRF

https://blog.csdn.net/lgxzzz/article/details/125010336

### XSS 跨站脚本攻击

**反射型原理：**

- 攻击者在url后面的参数中加入恶意攻击代码
- 当用户打开带有恶意代码的url链接的时候，网站的服务器将恶意代码从url中取出，然后拼接到html中返回给浏览器端
- 用户浏览器接受到后相应并解析代码，其中的恶意代码也会被执行到

**存储型原理：**

- 攻击者将恶意代码存放到目标网站的数据库中
- 用户浏览目标网站的时候，网站服务器从数据库中把恶意代码取出，然后拼接到html后返回给浏览器
- 浏览器接受到响应后解析并执行，其中恶意代码也会被执行

**DOM型原理：**

* 被执行的恶意脚本会修改页面脚本结构

**解决方案：**

* 响应头中开启浏览器 X-XSS-Protection 浏览器防御设置
* 对 HTML 节点内容使用 HTML 编码（进行转义），防止其执行
* 对 HTML 属性进行转义实现防御
* 防御 JS 代码，对代码进行 JSON 序列化
* URL编码，将不可信数据作为 URL 参数值时需要对参数进行 URL 编码
* 设置头部 Content-Security-Policy 开启 CSP 防御策略



### CSRF 跨站请求伪造

**原理：**跨站请求伪造与XSS不同的是，XSS是攻击者直接对我们的网站A进行注入攻击，CSRF是通过网站B对我们的网站A进行伪造请求。

**解决方案：**

* 尽量使用 POST，少用 GET
* Cookie 设置成 httpOnly，设置 sameSite
* 增加 token
* 验证请求头的 referer
* 增加验证码





## 前端性能优化

[性能优化指标](https://juejin.cn/post/6844904200044806157#heading-6)

[性能优化八股](https://juejin.cn/post/6892994632968306702)





## 上传大文件

[前端上传大文件怎么处理](https://juejin.cn/post/7053658552472174605)

[字节跳动面试官：请你实现一个大文件上传和断点续传](https://juejin.cn/post/7053658552472174605)

**思路：**

* 通过 input 标签上传的文件类型是 File 类型，继承自 Blob，而 `Blob.prototype.slice` 方法可以对文件进行切片
* 将分割后的切片存储到对象中，同时存储当前 hash 值
* 通过 FormData 数据格式进行传输，可加入并发控制及断点续传等逻辑
* 通过 catch 捕获传输失败的分片，递归地进行继续传输
* 直到所有分片传输成功，发送合并请求，后端根据 hash 值进行数据合并
